{"version":3,"file":"datapos-connector-file-store-emulator.es.js","sources":["../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-errors.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-utilities.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-tools.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-locale.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-dataview.es.js","../src/rustBridge.ts","../src/index.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","class i extends Error {\n  locator;\n  /** Logical source of the error. */\n  constructor(n, o, e) {\n    super(n, e), this.name = new.target.name, this.locator = o;\n  }\n}\nclass a extends i {\n}\nclass d extends a {\n}\nclass f extends a {\n}\nclass c extends a {\n  body;\n  /** Sanitized HTTP response body. */\n  constructor(n, o, e, t) {\n    super(n, o, t), this.name = new.target.name, this.body = b(e ?? void 0);\n  }\n}\nclass g extends i {\n}\nclass l extends a {\n  componentName;\n  /** Vue component name, if available. */\n  info;\n  /** Vue error info string. */\n  constructor(n, o, e, t, s) {\n    super(n, o, s), this.name = new.target.name, this.info = e, this.componentName = t;\n  }\n}\nclass E extends a {\n}\nclass u extends a {\n}\nasync function y(r, n, o) {\n  const e = ` - ${r.statusText}`, t = `${n} Response status '${r.status}${r.statusText ? e : \"\"}' received.`;\n  let s;\n  try {\n    s = await r.text();\n  } catch (m) {\n    s = `<body unavailable: ${w(m).message}>`;\n  }\n  return new c(t, o, s);\n}\nfunction h(r) {\n  return r.map((n) => n.message).join(\" \");\n}\nfunction R(r) {\n  try {\n    r();\n  } catch {\n  }\n}\nfunction w(r) {\n  if (r instanceof Error) return r;\n  if (typeof r == \"string\") return new Error(r);\n  if (typeof r == \"number\" || typeof r == \"boolean\" || typeof r == \"bigint\") return new Error(String(r));\n  if (typeof r == \"symbol\") return new Error(r.description ?? \"Unknown error\");\n  if (r != null && typeof r == \"object\")\n    try {\n      return new Error(JSON.stringify(r));\n    } catch {\n      return new Error(\"Unknown error\");\n    }\n  return new Error(\"Unknown error\");\n}\nfunction x(r) {\n  const n = /* @__PURE__ */ new Set(), o = [];\n  let e = r;\n  for (; e != null && !n.has(e); ) {\n    n.add(e);\n    let t;\n    if (e instanceof c)\n      t = { componentName: void 0, body: e.body, info: void 0, locator: e.locator, message: e.message, name: e.name, stack: e.stack }, e = e.cause;\n    else if (e instanceof l)\n      t = {\n        componentName: e.componentName,\n        body: void 0,\n        info: e.info,\n        locator: e.locator,\n        message: e.message,\n        name: e.name,\n        stack: e.stack\n      }, e = e.cause;\n    else if (e instanceof i)\n      t = { componentName: void 0, body: void 0, info: void 0, locator: e.locator, message: e.message, name: e.name, stack: e.stack }, e = e.cause;\n    else if (e instanceof Error) {\n      const s = e;\n      t = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: s.message, name: s.name, stack: s.stack }, e = s.cause;\n    } else\n      t = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: p(e), name: \"Error\", stack: void 0 }, e = void 0;\n    /(?:\\.{3}|[.!?])$/.test(t.message) || (t.message += \".\"), o.push(t);\n  }\n  return o;\n}\nfunction v(r) {\n  if (r.length === 0) return;\n  let n;\n  for (const o of r.toReversed()) {\n    let e;\n    if (o.body !== void 0)\n      e = new c(o.message, o.locator, o.body, { cause: n });\n    else if (o.info !== void 0)\n      e = new l(o.message, o.locator, o.info, o.componentName, { cause: n });\n    else if (o.locator === \"\")\n      e = new Error(o.message, { cause: n }), e.name = o.name;\n    else\n      switch (o.name) {\n        case \"APIError\":\n          e = new d(o.message, o.locator, { cause: n });\n          break;\n        case \"EngineError\":\n          e = new f(o.message, o.locator, { cause: n });\n          break;\n        case \"ApplicationError\":\n          e = new a(o.message, o.locator, { cause: n });\n          break;\n        case \"OperationalError\":\n          e = new g(o.message, o.locator, { cause: n });\n          break;\n        case \"WindowHandledRuntimeError\":\n          e = new E(o.message, o.locator, { cause: n });\n          break;\n        case \"WindowHandledPromiseRejectionError\":\n          e = new u(o.message, o.locator, { cause: n });\n          break;\n        default:\n          e = new i(o.message, o.locator, { cause: n });\n          break;\n      }\n    o.stack !== void 0 && (e.stack = o.stack), n = e;\n  }\n  return n;\n}\nfunction p(r) {\n  let n;\n  try {\n    n = JSON.stringify(r);\n  } catch {\n    typeof r == \"symbol\" ? n = r.description ?? \"Unknown error\" : typeof r == \"bigint\" ? n = r.toString() : n = \"Unknown error\";\n  }\n  return n === \"\" && (n = \"Unknown error\"), n;\n}\nfunction b(r) {\n  if (!(r == null || r === \"\"))\n    return r.length > 2048 ? `${r.slice(0, 2048)}... [truncated]` : r;\n}\nexport {\n  d as APIError,\n  a as ApplicationError,\n  f as EngineError,\n  c as FetchError,\n  g as OperationalError,\n  l as VueHandledError,\n  u as WindowHandledPromiseRejectionError,\n  E as WindowHandledRuntimeError,\n  y as buildFetchError,\n  h as concatenateSerialisedErrorMessages,\n  R as ignoreErrors,\n  w as normalizeToError,\n  x as serialiseError,\n  v as unserialiseError\n};\n","const c = \"en-US\", s = /* @__PURE__ */ new Map();\nfunction f(e) {\n  switch (e) {\n    case \"Edm.Binary\":\n      return \"unknown\";\n    // Binary...\n    case \"Edm.Boolean\":\n      return \"boolean\";\n    case \"Edm.Byte\":\n      return \"wholeNumber\";\n    case \"Edm.DateTime\":\n      return \"moment\";\n    // DateTime...\n    case \"Edm.DateTimeOffset\":\n      return \"moment\";\n    // DateTimeOffset...\n    case \"Edm.Decimal\":\n      return \"decimalNumber\";\n    case \"Edm.Double\":\n      return \"decimalNumber\";\n    case \"Edm.Guid\":\n      return \"string\";\n    case \"Edm.Int16\":\n      return \"wholeNumber\";\n    case \"Edm.Int32\":\n      return \"wholeNumber\";\n    case \"Edm.Int64\":\n      return \"wholeNumber\";\n    case \"Edm.SByte\":\n      return \"wholeNumber\";\n    case \"Edm.Single\":\n      return \"decimalNumber\";\n    case \"Edm.String\":\n      return \"string\";\n    case \"Edm.Time\":\n      return \"momentTime\";\n    // Time...\n    default:\n      return \"unknown\";\n  }\n}\nfunction l(e) {\n  if (e) {\n    const t = e.lastIndexOf(\"/\"), n = e.lastIndexOf(\".\", t === -1 ? e.length : t);\n    return n === -1 ? e : e.slice(0, Math.max(0, n));\n  }\n}\nfunction m(e) {\n  if (e) {\n    const t = e.lastIndexOf(\".\");\n    if (t !== -1) return e.slice(Math.max(0, t + 1));\n  }\n}\nfunction r(e, t = 2, n = t, i = c) {\n  if (e == null) return \"\";\n  const u = `${i}decimal${t}.${n}`;\n  let a = s.get(u);\n  return a || (a = new Intl.NumberFormat(i, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: t,\n    minimumFractionDigits: n,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(u, a)), a.format(e);\n}\nfunction d(e) {\n  return e == null ? \"\" : e < 1e3 ? o(e) : e < 1e6 ? `${r(e / 1e3, 2, 0)}K` : e < 1e9 ? `${r(e / 1e6, 2, 0)}M` : e < 1e12 ? `${r(e / 1e9, 2, 0)}B` : `${r(e / 1e12, 2, 0)}T`;\n}\nfunction x(e) {\n  return e == null ? \"\" : e === 1 ? \"1 byte\" : e < 1024 ? `${o(e)} bytes` : e < 1048576 ? `${r(e / 1024, 2, 0)} KB` : e < 1073741824 ? `${r(e / 1048576, 2, 0)} MB` : e < 1099511627776 ? `${r(e / 1073741824, 2, 0)} GB` : `${r(e / 1099511627776, 2, 0)} TB`;\n}\nfunction p(e) {\n  return e == null ? \"\" : e < 1e3 ? `${o(e)} ms` : e === 1e3 ? `${o(e)} sec` : e < 6e4 ? `${r(e / 1e3, 2, 0)} secs` : e === 6e4 ? \"1 min\" : e < 36e5 ? `${r(e / 6e4, 2, 0)} mins` : e === 36e5 ? \"1 hr\" : e < 864e5 ? `${r(e / 36e5, 2, 0)} hrs` : e === 864e5 ? \"1 day\" : `${r(e / 864e5, 2, 0)} days`;\n}\nfunction o(e, t = c) {\n  if (e == null) return \"\";\n  const n = `${t}decimal0.0`;\n  let i = s.get(n);\n  return i || (i = new Intl.NumberFormat(t, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: 0,\n    minimumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(n, i)), i.format(e);\n}\nfunction E(e) {\n  switch (e) {\n    case \"csv\":\n      return \"text/csv\";\n    case \"tab\":\n    case \"tsv\":\n      return \"text/tab-separated-values\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\nexport {\n  f as convertODataTypeIdToUsageTypeId,\n  m as extractExtensionFromPath,\n  l as extractNameFromPath,\n  r as formatNumberAsDecimalNumber,\n  p as formatNumberAsDuration,\n  d as formatNumberAsSize,\n  x as formatNumberAsStorageSize,\n  o as formatNumberAsWholeNumber,\n  E as lookupMimeTypeForExtension\n};\n","async function a(e, o) {\n  const n = `datapos-tool-${o}`, t = e.find((r) => r.id === n);\n  if (!t) throw new Error(`Connector could not load unknown tool '${o}'.`);\n  const l = await import(`https://engine-eu.datapos.app/tools/${o}_v${t.version}/${n}.es.js`);\n  return new l.Tool();\n}\nexport {\n  a as loadTool\n};\n","const o = \"en-gb\", i = (e) => new Map(Object.entries(e)), s = (e, t, n = o) => {\n  const r = e.get(t);\n  if (r !== void 0) return r;\n  if (n !== t)\n    return e.get(n);\n};\nexport {\n  o as DEFAULT_LOCALE_CODE,\n  i as createLabelMap,\n  s as resolveLabel\n};\n","import { createLabelMap as e } from \"./datapos-shared-locale.es.js\";\ne({ \"en-gb\": \"Data Positioning Events\" }), e({ \"en-gb\": \"Delimited Text\" }), e({ \"en-gb\": \"JSON\" }), e({ \"en-gb\": \"SPSS\" }), e({ \"en-gb\": \"XLSX\" }), e({ \"en-gb\": \"XML\" });\ne({ \"en-gb\": \"Newline\" }), e({ \"en-gb\": \"Carriage Return\" }), e({ \"en-gb\": \"Carriage Return/Newline\" });\ne({ \"en-gb\": \"Colon\" }), e({ \"en-gb\": \"Comma\" }), e({ \"en-gb\": \"Exclamation Mark\" }), e({ \"en-gb\": \"Record Separator\" }), e({ \"en-gb\": \"Semicolon\" }), e({ \"en-gb\": \"Space\" }), e({ \"en-gb\": \"Tab\" }), e({ \"en-gb\": \"Underscore\" }), e({ \"en-gb\": \"Unit Separator\" }), e({ \"en-gb\": \"Vertical Bar\" });\nconst a = [\",\", \";\", \"\t\", \"|\", \" \", \":\", \"_\", \"!\", \"0x1F\", \"0x1E\"];\nexport {\n  a as ORDERED_VALUE_DELIMITER_IDS\n};\n","// Dependencies - Framework\nimport type * as RustModule from '../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js';\n\n// Interfaces/Types\ntype RustBindings = typeof RustModule;\n\n// Module Variables\nlet rustBindingsPromise: Promise<RustBindings> | undefined;\n\n// Utilities\nasync function addNumbersWithRust(left: number, right: number): Promise<number> {\n    const { add_my_numbers } = await loadRustBindings();\n    console.log(1111, left, right);\n    const yyyy = add_my_numbers(Math.trunc(left), Math.trunc(right));\n    console.log(2222, yyyy);\n    return yyyy;\n}\n\n// Utilities\nasync function checksumWithRust(input: string): Promise<number> {\n    const { checksum_from_rust } = await loadRustBindings();\n    return checksum_from_rust(input);\n}\n\n// Helpers\nasync function loadRustBindings(): Promise<RustBindings> {\n    rustBindingsPromise ??= import('../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js');\n    return rustBindingsPromise;\n}\n\n// Exposures\nexport { addNumbersWithRust, checksumWithRust };\n","/**\n * File store emulator connector.\n */\n\n// Vendor dependencies.\nimport { nanoid } from 'nanoid';\n\n// Framework dependencies.\nimport type { Tool as CSVParseTool } from '@datapos/datapos-tool-csv-parse';\nimport type { EngineUtilities } from '@datapos/datapos-shared/engine';\nimport type { Tool as FileOperatorsTool } from '@datapos/datapos-tool-file-operators';\nimport type { Tool as RustCsvCoreTool } from '@datapos/datapos-tool-rust-csv-core';\nimport type {\n    AuditObjectContentOptions,\n    AuditObjectContentResult,\n    ConnectionNodeConfig,\n    ConnectorConfig,\n    ConnectorInterface,\n    FindObjectFolderPathOptions,\n    GetReadableStreamOptions,\n    ListNodesOptions,\n    ListNodesResult,\n    PreviewObjectOptions,\n    RetrieveRecordsOptions,\n    RetrieveRecordsSummary\n} from '@datapos/datapos-shared/component/connector';\nimport { buildFetchError, normalizeToError, OperationalError } from '@datapos/datapos-shared/errors';\nimport { extractExtensionFromPath, extractNameFromPath, lookupMimeTypeForExtension } from '@datapos/datapos-shared/utilities';\nimport { loadTool, type ToolConfig } from '@datapos/datapos-shared/component/tool';\nimport { ORDERED_VALUE_DELIMITER_IDS, type ParsingRecord, type PreviewConfig } from '@datapos/datapos-shared/component/dataView';\n\n// Data dependencies.\nimport config from '~/config.json';\nimport fileStoreFolderPathData from '@/fileStoreFolderPaths.json';\n\n// TODO\nimport { addNumbersWithRust, checksumWithRust } from '@/rustBridge';\n\n/**\n * File store folder paths.\n */\ntype FileStoreFolderNode =\n    | ({ typeId: 'folder'; childCount: number } & { name: string })\n    | ({ typeId: 'object'; id: string; lastModifiedAt: number; size: number } & { name: string });\n\n/**\n *\n */\ntype FileStoreFolderPaths = Record<string, FileStoreFolderNode[]>;\n\n/**\n *\n */\nconst URL_PREFIX = 'https://sample-data-eu.datapos.app';\n\n/**\n * File store emulator connector.\n */\nclass Connector implements ConnectorInterface {\n    abortController: AbortController | undefined;\n    readonly config: ConnectorConfig;\n    engineUtilities: EngineUtilities;\n    readonly toolConfigs;\n\n    constructor(engineUtilities: EngineUtilities, toolConfigs: ToolConfig[]) {\n        this.abortController = undefined;\n        this.config = config as ConnectorConfig;\n        this.engineUtilities = engineUtilities;\n        this.toolConfigs = toolConfigs;\n    }\n\n    //━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n    //#region: Operations.\n    //━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n    /**\n     * Abort the currently running operation.\n     */\n    abortOperation(): void {\n        if (!this.abortController) return;\n        this.abortController.abort();\n        this.abortController = undefined;\n    }\n\n    // /**\n    //  * Audit the content of a CSV file using Rust CSV parser.\n    //  * Automatically selects the appropriate processing mode based on browser capabilities.\n    //  */\n    // async auditContent(path: string, supportsTransferableStreams: boolean, onProgress?: (rowCount: number) => void): Promise<{ processedRowCount: number; durationMs?: number }> {\n    //     this.abortController = new AbortController();\n\n    //     try {\n    //         // Get the readable stream\n    //         const stream = await this.getReadableStream({ id: '', path });\n\n    //         // Load the Rust CSV core tool\n    //         const rustCsvTool = await loadTool<RustCsvCoreTool>(this.toolConfigs, 'rust-csv-core');\n\n    //         // Choose processing mode based on browser capability\n    //         const options = { delimiter: ',', hasHeaders: true };\n    //         const result = supportsTransferableStreams\n    //             ? await rustCsvTool.processWithTransferableStream(stream, options, onProgress)\n    //             : await rustCsvTool.processWithChunks(stream, options, onProgress);\n\n    //         return {\n    //             processedRowCount: result.processedRowCount,\n    //             durationMs: result.durationMs ?? 0\n    //         };\n    //     } catch (error) {\n    //         throw normalizeToError(error);\n    //     } finally {\n    //         this.abortController = undefined;\n    //     }\n    // }\n\n    /**\n     * Audit object content.\n     */\n    async auditObjectContent(options: AuditObjectContentOptions, chunk: (rowCount: number) => void): Promise<AuditObjectContentResult> {\n        this.abortController = new AbortController();\n\n        try {\n            if (options.parsingToolName === 'datapos-tool-rust-csv-core') {\n                // Get the readable stream\n                const stream = await this.getReadableStream({ id: '', path: options.path });\n\n                // Load the Rust CSV core tool\n                const rustCsvTool = await loadTool<RustCsvCoreTool>(this.toolConfigs, 'rust-csv-core');\n\n                // Choose processing mode based on browser capability\n                const options2 = { delimiter: ',', hasHeaders: true };\n                const result = options.supportsTransferableStreams\n                    ? await rustCsvTool.processWithTransferableStream(stream, options2, chunk)\n                    : await rustCsvTool.processWithChunks(stream, options2, chunk);\n\n                return { processedRowCount: result.processedRowCount, durationMs: result.durationMs ?? 0 };\n            }\n\n            const csvParseTool = await loadTool<CSVParseTool>(this.toolConfigs, 'csv-parse');\n            const parseStreamOptions = { delimiter: options.valueDelimiterId, info: false, relax_column_count: true, relax_quotes: true };\n            const url = `${URL_PREFIX}/fileStore${options.path}`;\n            const summary = await csvParseTool.parseStream(options, parseStreamOptions, url, this.abortController, chunk);\n            console.log('summary', summary);\n            // complete(summary);\n\n            return { processedRowCount: 0, durationMs: 0 };\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            this.abortController = undefined;\n        }\n    }\n\n    /**\n     * Find the folder path containing the specified object node.\n     */\n    findObjectFolderPath(options: FindObjectFolderPathOptions): Promise<string | null> {\n        const fileStoreFolderPaths = fileStoreFolderPathData as FileStoreFolderPaths;\n        // Loop through the folder path data checking for an object entry with an identifier equal to the object name.\n        for (const folderPath in fileStoreFolderPaths) {\n            if (Object.hasOwn(fileStoreFolderPaths, folderPath)) {\n                // eslint-disable-next-line security/detect-object-injection\n                const folderPathNodes = fileStoreFolderPaths[folderPath];\n                const folderPathNode = folderPathNodes?.find((folderPathNode) => folderPathNode.typeId === 'object' && folderPathNode.id === options.nodeId);\n                if (folderPathNode) return Promise.resolve(folderPath); // Found, return folder path.\n            }\n        }\n        return Promise.resolve(null); // Not found.\n    }\n\n    /**\n     * Get a readable stream for the specified object node path.\n     */\n    async getReadableStream(options: GetReadableStreamOptions): Promise<ReadableStream<Uint8Array>> {\n        // Create an abort controller and extract its signal.\n        const { signal } = (this.abortController = new AbortController());\n\n        try {\n            const response = await fetch(`${URL_PREFIX}/fileStore${options.path}`, { signal });\n            if (!response.ok) {\n                throw await buildFetchError(response, `Failed to fetch '${options.path}' file.`, 'datapos-connector-file-store-emulator|Connector|getReadableStream');\n            }\n            if (response.body == null) {\n                throw new OperationalError('Readable streams are not supported in this runtime.', 'datapos-connector-file-store-emulator|Connector|getReadableStream.unsupported');\n            }\n\n            // TODO: Remove after testing.\n            const xxx = await addNumbersWithRust(12, 56);\n            const sum = await checksumWithRust(this.config.version);\n            console.log('sum', sum, xxx);\n\n            return await Promise.resolve(response.body);\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            this.abortController = undefined;\n        }\n    }\n\n    /**\n     * Lists all nodes (folders and objects) in the specified folder path.\n     */\n    listNodes(options: ListNodesOptions): Promise<ListNodesResult> {\n        const fileStoreFolderPaths = fileStoreFolderPathData as FileStoreFolderPaths;\n        const folderNodes = fileStoreFolderPaths[options.folderPath] ?? [];\n        const connectionNodeConfigs: ConnectionNodeConfig[] = [];\n        for (const folderNode of folderNodes) {\n            if (folderNode.typeId === 'folder') {\n                connectionNodeConfigs.push(constructFolderNodeConfig(options.folderPath, folderNode.name, folderNode.childCount));\n            } else {\n                connectionNodeConfigs.push(constructObjectNodeConfig(options.folderPath, folderNode.id, folderNode.name, folderNode.lastModifiedAt, folderNode.size));\n            }\n        }\n        return Promise.resolve({ cursor: undefined, isMore: false, connectionNodeConfigs, totalCount: connectionNodeConfigs.length });\n    }\n\n    /**\n     * Preview the contents of the object node with the specified path.\n     */\n    async previewObject(options: PreviewObjectOptions): Promise<PreviewConfig> {\n        // Create an abort controller and extract its signal.\n        const { signal } = (this.abortController = new AbortController());\n\n        try {\n            const asAt = Date.now();\n            const startedAt = performance.now();\n\n            // Preview file to determine file format and decode text.\n            const fileOperatorsTool = await loadTool<FileOperatorsTool>(this.toolConfigs, 'file-operators');\n            const filePreviewResult = await fileOperatorsTool.previewFile(`${URL_PREFIX}/fileStore${options.path}`, signal, options.chunkSize);\n            if (filePreviewResult.dataFormatId == null) throw new Error(`File '${options.path}' has unknown type.`);\n            if (filePreviewResult.text == null) throw new Error(`File '${options.path}' is empty.`);\n\n            // Parse text, identify delimiters, and produce string value records.\n            const csvParseTool = await loadTool<CSVParseTool>(this.toolConfigs, 'csv-parse');\n            const parseTextResult = await csvParseTool.parseText(filePreviewResult.text, ORDERED_VALUE_DELIMITER_IDS);\n\n            // Infer and cast values for each parsed record.\n            const inferenceSummary = this.engineUtilities.inferDataTypes(parseTextResult.parsedRecords);\n\n            return {\n                asAt,\n                columnConfigs: inferenceSummary.columnConfigs,\n                dataFormatId: filePreviewResult.dataFormatId,\n                duration: performance.now() - startedAt,\n                encodingId: filePreviewResult.encodingId,\n                encodingConfidenceLevel: filePreviewResult.encodingConfidenceLevel,\n                fileType: filePreviewResult.fileTypeConfig,\n                hasHeaders: inferenceSummary.hasHeaderRow,\n                recordDelimiterId: parseTextResult.recordDelimiterId,\n                parsedRecords: parseTextResult.parsedRecords,\n                inferenceRecords: inferenceSummary.typedRecords,\n                size: filePreviewResult.bytes.length,\n                text: filePreviewResult.text,\n                valueDelimiterId: parseTextResult.valueDelimiterId\n            } as PreviewConfig;\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            this.abortController = undefined;\n        }\n    }\n    /**\n     * Retrieves all records from a CSV object node using streaming and chunked processing.\n     */\n    async retrieveRecords(options: RetrieveRecordsOptions, chunk: (records: ParsingRecord[]) => void, complete: (result: RetrieveRecordsSummary) => void): Promise<void> {\n        this.abortController = new AbortController();\n\n        try {\n            const csvParseTool = await loadTool<CSVParseTool>(this.toolConfigs, 'csv-parse');\n            const parseStreamOptions = { delimiter: options.valueDelimiterId, info: true, relax_column_count: true, relax_quotes: true };\n            const url = `${URL_PREFIX}/fileStore${options.path}`;\n            const summary = await csvParseTool.parseStream(options, parseStreamOptions, url, this.abortController, chunk);\n            complete(summary);\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            this.abortController = undefined;\n        }\n    }\n\n    //#endregion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n}\n\n//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n//#region: Helpers.\n//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Construct folder node configuration.\n */\nfunction constructFolderNodeConfig(folderPath: string, name: string, childCount: number): ConnectionNodeConfig {\n    return {\n        childCount,\n        childNodes: [],\n        extension: undefined,\n        folderPath,\n        handle: undefined,\n        id: nanoid(),\n        label: name,\n        lastModifiedAt: undefined,\n        mimeType: undefined,\n        name,\n        size: undefined,\n        typeId: 'folder'\n    };\n}\n\n/**\n * Construct object (file) node configuration.\n */\nfunction constructObjectNodeConfig(folderPath: string, id: string, fullName: string, lastModifiedAt: number, size: number): ConnectionNodeConfig {\n    const name = extractNameFromPath(fullName) ?? '';\n    const extension = extractExtensionFromPath(fullName);\n    const lastModifiedAtTimestamp = lastModifiedAt;\n    const mimeType = lookupMimeTypeForExtension(extension);\n    return {\n        childCount: undefined,\n        childNodes: [],\n        extension,\n        folderPath,\n        handle: undefined,\n        id,\n        label: fullName,\n        lastModifiedAt: lastModifiedAtTimestamp,\n        mimeType,\n        name,\n        size,\n        typeId: 'object'\n    };\n}\n\n//#endregion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// Exposures.\nexport { Connector };\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","n","o","e","i","c","a","t","b","g","y","r","s","m","w","l","E","rustBindingsPromise","addNumbersWithRust","left","right","add_my_numbers","loadRustBindings","yyyy","checksumWithRust","input","checksum_from_rust","URL_PREFIX","Connector","engineUtilities","toolConfigs","config","options","chunk","stream","rustCsvTool","loadTool","options2","result","csvParseTool","parseStreamOptions","url","summary","error","normalizeToError","fileStoreFolderPaths","fileStoreFolderPathData","folderPath","folderPathNode","signal","response","buildFetchError","OperationalError","xxx","sum","folderNodes","connectionNodeConfigs","folderNode","constructFolderNodeConfig","constructObjectNodeConfig","asAt","startedAt","filePreviewResult","parseTextResult","ORDERED_VALUE_DELIMITER_IDS","inferenceSummary","complete","name","childCount","fullName","lastModifiedAt","extractNameFromPath","extension","extractExtensionFromPath","lastModifiedAtTimestamp","mimeType","lookupMimeTypeForExtension"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}