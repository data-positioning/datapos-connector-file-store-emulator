{"version":3,"file":"datapos-connector-file-store-emulator.es.js","sources":["../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-utilities.es.js","../src/rustBridge.ts","../src/index.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","let M;\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return {\n    lang: t?.lang ?? M?.lang,\n    message: t?.message,\n    abortEarly: t?.abortEarly ?? M?.abortEarly,\n    abortPipeEarly: t?.abortPipeEarly ?? M?.abortPipeEarly\n  };\n}\nlet z;\n// @__NO_SIDE_EFFECTS__\nfunction H(t) {\n  return z?.get(t);\n}\nlet $;\n// @__NO_SIDE_EFFECTS__\nfunction W(t) {\n  return $?.get(t);\n}\nlet X;\n// @__NO_SIDE_EFFECTS__\nfunction B(t, n) {\n  return X?.get(t)?.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(t) {\n  const n = typeof t;\n  return n === \"string\" ? `\"${t}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${t}` : n === \"object\" || n === \"function\" ? (t && Object.getPrototypeOf(t)?.constructor?.name) ?? \"null\" : n;\n}\nfunction y(t, n, e, r, s) {\n  const o = s && \"input\" in s ? s.input : e.value, i = s?.expected ?? t.expects ?? null, u = s?.received ?? /* @__PURE__ */ _(o), a = {\n    kind: t.kind,\n    type: t.type,\n    input: o,\n    expected: i,\n    received: u,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: t.requirement,\n    path: s?.path,\n    issues: s?.issues,\n    lang: r.lang,\n    abortEarly: r.abortEarly,\n    abortPipeEarly: r.abortPipeEarly\n  }, p = t.kind === \"schema\", d = s?.message ?? t.message ?? /* @__PURE__ */ B(t.reference, a.lang) ?? (p ? /* @__PURE__ */ W(a.lang) : null) ?? r.message ?? /* @__PURE__ */ H(a.lang);\n  d !== void 0 && (a.message = typeof d == \"function\" ? d(a) : d), p && (e.typed = !1), e.issues ? e.issues.push(a) : e.issues = [a];\n}\n// @__NO_SIDE_EFFECTS__\nfunction g(t) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return t[\"~run\"]({ value: n }, /* @__PURE__ */ V());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(t, n) {\n  return Object.hasOwn(t, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction K(t, n) {\n  const e = [...new Set(t)];\n  return e.length > 1 ? `(${e.join(` ${n} `)})` : e[0] ?? \"never\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(t, n, e) {\n  return typeof t.fallback == \"function\" ? t.fallback(n, e) : t.fallback;\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(t, n, e) {\n  return typeof t.default == \"function\" ? t.default(n, e) : t.default;\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: E,\n    expects: \"Array\",\n    async: !1,\n    item: t,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      const s = e.value;\n      if (Array.isArray(s)) {\n        e.typed = !0, e.value = [];\n        for (let o = 0; o < s.length; o++) {\n          const i = s[o], u = this.item[\"~run\"]({ value: i }, r);\n          if (u.issues) {\n            const a = {\n              type: \"array\",\n              origin: \"value\",\n              input: s,\n              key: o,\n              value: i\n            };\n            for (const p of u.issues)\n              p.path ? p.path.unshift(a) : p.path = [a], e.issues?.push(p);\n            if (e.issues || (e.issues = u.issues), r.abortEarly) {\n              e.typed = !1;\n              break;\n            }\n          }\n          u.typed || (e.typed = !1), e.value.push(u.value);\n        }\n      } else y(this, \"type\", e, r);\n      return e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(t) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: T,\n    expects: \"boolean\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, e) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : y(this, \"type\", n, e), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: k,\n    expects: /* @__PURE__ */ _(t),\n    async: !1,\n    literal: t,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      return e.value === this.literal ? e.typed = !0 : y(this, \"type\", e, r), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction m(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: m,\n    expects: `(${t.expects} | null)`,\n    async: !1,\n    wrapped: t,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      return e.value === null && (this.default !== void 0 && (e.value = /* @__PURE__ */ w(this, e, r)), e.value === null) ? (e.typed = !0, e) : this.wrapped[\"~run\"](e, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(t) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: x,\n    expects: \"number\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, e) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : y(this, \"type\", n, e), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction b(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: b,\n    expects: \"Object\",\n    async: !1,\n    entries: t,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      const s = e.value;\n      if (s && typeof s == \"object\") {\n        e.typed = !0, e.value = {};\n        for (const o in this.entries) {\n          const i = this.entries[o];\n          if (o in s || (i.type === \"exact_optional\" || i.type === \"optional\" || i.type === \"nullish\") && i.default !== void 0) {\n            const u = o in s ? s[o] : /* @__PURE__ */ w(i), a = i[\"~run\"]({ value: u }, r);\n            if (a.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: o,\n                value: u\n              };\n              for (const d of a.issues)\n                d.path ? d.path.unshift(p) : d.path = [p], e.issues?.push(d);\n              if (e.issues || (e.issues = a.issues), r.abortEarly) {\n                e.typed = !1;\n                break;\n              }\n            }\n            a.typed || (e.typed = !1), e.value[o] = a.value;\n          } else if (i.fallback !== void 0) e.value[o] = /* @__PURE__ */ q(i);\n          else if (i.type !== \"exact_optional\" && i.type !== \"optional\" && i.type !== \"nullish\" && (y(this, \"key\", e, r, {\n            input: void 0,\n            expected: `\"${o}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input: s,\n              key: o,\n              value: s[o]\n            }]\n          }), r.abortEarly))\n            break;\n        }\n      } else y(this, \"type\", e, r);\n      return e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction f(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: f,\n    expects: `(${t.expects} | undefined)`,\n    async: !1,\n    wrapped: t,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      return e.value === void 0 && (this.default !== void 0 && (e.value = /* @__PURE__ */ w(this, e, r)), e.value === void 0) ? (e.typed = !0, e) : this.wrapped[\"~run\"](e, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(t, n, e) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: R,\n    expects: \"Object\",\n    async: !1,\n    key: t,\n    value: n,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(r, s) {\n      const o = r.value;\n      if (o && typeof o == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in o) if (/* @__PURE__ */ J(o, i)) {\n          const u = o[i], a = this.key[\"~run\"]({ value: i }, s);\n          if (a.issues) {\n            const d = {\n              type: \"object\",\n              origin: \"key\",\n              input: o,\n              key: i,\n              value: u\n            };\n            for (const S of a.issues)\n              S.path = [d], r.issues?.push(S);\n            if (r.issues || (r.issues = a.issues), s.abortEarly) {\n              r.typed = !1;\n              break;\n            }\n          }\n          const p = this.value[\"~run\"]({ value: u }, s);\n          if (p.issues) {\n            const d = {\n              type: \"object\",\n              origin: \"value\",\n              input: o,\n              key: i,\n              value: u\n            };\n            for (const S of p.issues)\n              S.path ? S.path.unshift(d) : S.path = [d], r.issues?.push(S);\n            if (r.issues || (r.issues = p.issues), s.abortEarly) {\n              r.typed = !1;\n              break;\n            }\n          }\n          (!a.typed || !p.typed) && (r.typed = !1), a.typed && (r.value[a.value] = p.value);\n        }\n      } else y(this, \"type\", r, s);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction l(t) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: l,\n    expects: \"string\",\n    async: !1,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(n, e) {\n      return typeof n.value == \"string\" ? n.typed = !0 : y(this, \"type\", n, e), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction P(t) {\n  let n;\n  if (t) for (const e of t) n ? n.push(...e.issues) : n = e.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(t, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: U,\n    expects: /* @__PURE__ */ K(t.map((e) => e.expects), \"|\"),\n    async: !1,\n    options: t,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ g(this);\n    },\n    \"~run\"(e, r) {\n      let s, o, i;\n      for (const u of this.options) {\n        const a = u[\"~run\"]({ value: e.value }, r);\n        if (a.typed) if (a.issues) o ? o.push(a) : o = [a];\n        else {\n          s = a;\n          break;\n        }\n        else i ? i.push(a) : i = [a];\n      }\n      if (s) return s;\n      if (o) {\n        if (o.length === 1) return o[0];\n        y(this, \"type\", e, r, { issues: /* @__PURE__ */ P(o) }), e.typed = !0;\n      } else {\n        if (i?.length === 1) return i[0];\n        y(this, \"type\", e, r, { issues: /* @__PURE__ */ P(i) });\n      }\n      return e;\n    }\n  };\n}\nconst h = (t) => /* @__PURE__ */ U(t.map((n) => /* @__PURE__ */ k(n))), Q = /* @__PURE__ */ b({\n  \"en-au\": /* @__PURE__ */ l(),\n  \"en-gb\": /* @__PURE__ */ l(),\n  \"en-us\": /* @__PURE__ */ l(),\n  \"es-es\": /* @__PURE__ */ l()\n}), j = /* @__PURE__ */ b({\n  \"en-au\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"en-gb\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"en-us\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"es-es\": /* @__PURE__ */ f(/* @__PURE__ */ l())\n}), Y = h([\"amber\", \"green\", \"red\", \"other\"]), Z = h([\n  \"alpha\",\n  \"beta\",\n  \"generalAvailability\",\n  \"notApplicable\",\n  \"preAlpha\",\n  \"proposed\",\n  \"releaseCandidate\",\n  \"unavailable\",\n  \"underReview\"\n]), ee = h([\n  \"app\",\n  \"connector\",\n  \"connectorConnection\",\n  \"context\",\n  \"contextModelGroup\",\n  \"contextModel\",\n  \"contextModelDimensionGroup\",\n  \"contextModelDimension\",\n  \"contextModelDimensionHierarchy\",\n  \"contextModelEntityGroup\",\n  \"contextModelEntity\",\n  \"contextModelEntityDataItem\",\n  \"contextModelEntityEvent\",\n  \"contextModelEntityPrimaryMeasure\",\n  \"contextModelSecondaryMeasureGroup\",\n  \"contextModelSecondaryMeasure\",\n  \"dataView\",\n  \"dimension\",\n  \"engine\",\n  \"eventQuery\",\n  \"presenter\",\n  \"presenterPresentation\",\n  \"tool\"\n]);\nh([\"app\", \"engine\", \"connector\", \"context\", \"presenter\", \"tool\"]);\nconst te = /* @__PURE__ */ b({\n  id: /* @__PURE__ */ l(),\n  color: Y,\n  label: /* @__PURE__ */ l()\n}), A = {\n  id: /* @__PURE__ */ l(),\n  label: j,\n  description: j,\n  firstCreatedAt: /* @__PURE__ */ f(/* @__PURE__ */ x()),\n  icon: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  iconDark: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  lastUpdatedAt: /* @__PURE__ */ m(/* @__PURE__ */ x()),\n  status: /* @__PURE__ */ m(te),\n  statusId: Z\n}, he = /* @__PURE__ */ b({\n  ...A,\n  typeId: ee\n}), I = {\n  ...A,\n  version: /* @__PURE__ */ l()\n}, F = /* @__PURE__ */ b({\n  id: /* @__PURE__ */ l(),\n  label: j,\n  description: j,\n  icon: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  iconDark: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  order: /* @__PURE__ */ x(),\n  path: /* @__PURE__ */ l()\n}), v = (t) => {\n  const n = Object.entries(t).filter((e) => typeof e[1] == \"string\");\n  return new Map(n);\n}, ne = (t, n, e = O) => {\n  const r = t.get(n);\n  if (r !== void 0) return r;\n  if (e !== n)\n    return t.get(e);\n}, re = [\n  { id: \"alpha\", color: \"red\", labels: v({ \"en-gb\": \"alpha\" }) },\n  { id: \"beta\", color: \"amber\", labels: v({ \"en-gb\": \"beta\" }) },\n  { id: \"generalAvailability\", color: \"green\", labels: v({ \"en-gb\": \"\" }) },\n  { id: \"notApplicable\", color: \"green\", labels: v({ \"en-gb\": \"not-applicable\" }) },\n  { id: \"preAlpha\", color: \"red\", labels: v({ \"en-gb\": \"pre-alpha\" }) },\n  { id: \"proposed\", color: \"other\", labels: v({ \"en-gb\": \"proposed\" }) },\n  { id: \"releaseCandidate\", color: \"green\", labels: v({ \"en-gb\": \"release-candidate\" }) },\n  { id: \"unavailable\", color: \"other\", labels: v({ \"en-gb\": \"unavailable\" }) },\n  { id: \"underReview\", color: \"other\", labels: v({ \"en-gb\": \"under-review\" }) }\n], ve = (t, n = O) => {\n  const e = re.find((r) => r.id === t);\n  if (e) {\n    const r = ne(e.labels, n);\n    return { id: e.id, color: e.color, label: r ?? e.id };\n  }\n  return { id: t, color: \"other\", label: t };\n}, se = h([\"apiKey\", \"disabled\", \"oAuth2\", \"none\"]), oe = h([\"application\", \"curatedDataset\", \"database\", \"fileStore\"]), ie = h([\n  \"abortOperation\",\n  \"authenticateConnection\",\n  \"createObject\",\n  \"describeConnection\",\n  \"dropObject\",\n  \"findObject\",\n  \"getReadableStream\",\n  \"getRecord\",\n  \"listNodes\",\n  \"previewObject\",\n  \"removeRecords\",\n  \"retrieveChunks\",\n  \"retrieveRecords\",\n  \"upsertRecords\"\n]), ae = h([\"bidirectional\", \"destination\", \"source\", \"unknown\"]), le = /* @__PURE__ */ b({\n  authMethodId: se,\n  activeConnectionCount: /* @__PURE__ */ f(/* @__PURE__ */ x()),\n  canDescribe: /* @__PURE__ */ f(/* @__PURE__ */ T()),\n  id: /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  label: /* @__PURE__ */ f(Q),\n  maxConnectionCount: /* @__PURE__ */ f(/* @__PURE__ */ x()),\n  params: /* @__PURE__ */ f(/* @__PURE__ */ E(/* @__PURE__ */ R(/* @__PURE__ */ l(), /* @__PURE__ */ l())))\n}), Ee = /* @__PURE__ */ b({\n  ...I,\n  typeId: /* @__PURE__ */ k(\"connector\"),\n  category: /* @__PURE__ */ m(/* @__PURE__ */ b({ id: /* @__PURE__ */ l(), label: /* @__PURE__ */ l() })),\n  categoryId: oe,\n  implementations: /* @__PURE__ */ R(/* @__PURE__ */ l(), le),\n  operations: /* @__PURE__ */ E(ie),\n  usageId: ae,\n  vendorAccountURL: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  vendorDocumentationURL: /* @__PURE__ */ m(/* @__PURE__ */ l()),\n  vendorHomeURL: /* @__PURE__ */ m(/* @__PURE__ */ l())\n}), Se = [\"createObject\", \"dropObject\", \"removeRecords\", \"upsertRecords\"], xe = [\"findObject\", \"getRecord\", \"listNodes\", \"previewObject\", \"retrieveRecords\"], D = (t) => {\n  const n = Object.entries(t).filter((e) => typeof e[1] == \"string\");\n  return new Map(n);\n};\nD({ \"en-gb\": \"Application\" }), D({ \"en-gb\": \"Curated Dataset\" }), D({ \"en-gb\": \"Database\" }), D({ \"en-gb\": \"File Store\" });\nconst ce = h([\"list\"]), ue = /* @__PURE__ */ b({\n  ...A,\n  typeId: /* @__PURE__ */ k(\"contextModelGroup\"),\n  modelRefs: /* @__PURE__ */ E(F),\n  order: /* @__PURE__ */ x()\n}), ke = /* @__PURE__ */ b({\n  ...I,\n  typeId: /* @__PURE__ */ k(\"context\"),\n  models: /* @__PURE__ */ E(ue),\n  operations: /* @__PURE__ */ E(ce)\n});\nclass L extends Error {\n  locator;\n  constructor(n, e, r) {\n    super(n, r), this.name = \"DataPosError\", this.locator = e;\n  }\n}\nclass C extends L {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"ApplicationError\";\n  }\n}\nclass Ce extends C {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"APIError\";\n  }\n}\nclass Oe extends C {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"EngineError\";\n  }\n}\nclass G extends C {\n  body;\n  constructor(n, e, r, s) {\n    super(n, e, s), this.name = \"FetchError\", this.body = r;\n  }\n}\nclass pe extends C {\n  componentName;\n  info;\n  constructor(n, e, r, s, o) {\n    super(n, e, o), this.name = \"VueHandledError\", this.info = r, this.componentName = s;\n  }\n}\nclass De extends C {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"WindowHandledRuntimeError\";\n  }\n}\nclass je extends C {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"WindowHandledPromiseRejectionError\";\n  }\n}\nclass Me extends L {\n  constructor(n, e, r) {\n    super(n, e, r), this.name = \"OperationalError\";\n  }\n}\nasync function we(t, n, e) {\n  const r = ` - ${t.statusText}`, s = `${n} Response status '${t.status}${t.statusText ? r : \"\"}' received.`, o = await t.text();\n  return new G(s, e, o);\n}\nfunction Re(t) {\n  return t.map((n) => n.message).join(\" \");\n}\nfunction Ae(t) {\n  if (t instanceof Error) return t;\n  if (typeof t == \"string\") return new Error(t);\n  if (typeof t == \"number\" || typeof t == \"boolean\" || typeof t == \"bigint\") return new Error(String(t));\n  if (typeof t == \"symbol\") return new Error(t.description ?? \"Unknown error\");\n  if (t && typeof t == \"object\")\n    try {\n      return new Error(JSON.stringify(t));\n    } catch {\n      return new Error(\"Unknown error\");\n    }\n  return new Error(\"Unknown error\");\n}\nfunction Ie(t) {\n  const n = /* @__PURE__ */ new Set(), e = [];\n  let r = t;\n  for (; r && !n.has(r); ) {\n    n.add(r);\n    let s;\n    if (r instanceof G)\n      s = { body: r.body, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof pe)\n      s = { componentName: r.componentName, info: r.info, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof L)\n      s = { locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof Error) {\n      const o = r;\n      s = { locator: \"\", message: o.message, name: o.name, stack: o.stack }, r = o.cause;\n    } else\n      s = { locator: \"\", message: String(r), name: \"Error\" }, r = void 0;\n    /(?:\\.{3}|[.!?])$/.test(s.message) || (s.message += \".\"), e.push(s);\n  }\n  return e;\n}\nconst de = h([\"list\", \"render\", \"setColorMode\"]), Le = /* @__PURE__ */ b({\n  ...I,\n  typeId: /* @__PURE__ */ k(\"presenter\"),\n  presentations: /* @__PURE__ */ E(F),\n  operations: /* @__PURE__ */ E(de)\n});\nfunction Ne() {\n  return { render: fe };\n}\nfunction fe(t, n, e) {\n  e.textContent = \"Cytoscape.js diagram goes here...\";\n}\nfunction Pe() {\n  return { render: be };\n}\nfunction be(t, n) {\n  console.log(1111, t), console.log(2222, n), console.log(3333, n.childNodes), console.log(4444, n.children);\n}\nconst c = (t) => new Map(Object.entries(t)), N = (t, n, e = O) => {\n  const r = t.get(n);\n  if (r !== void 0) return r;\n  if (e !== n)\n    return t.get(e);\n}, me = [\n  { id: \"dtv\", labels: c({ \"en-gb\": \"Delimited Text\" }) },\n  { id: \"e/e\", labels: c({ \"en-gb\": \"Entity/Event\" }) },\n  { id: \"jsonArray\", labels: c({ \"en-gb\": \"JSON Array\" }) },\n  { id: \"spss\", labels: c({ \"en-gb\": \"SPSS\" }) },\n  { id: \"xls\", labels: c({ \"en-gb\": \"XLS\" }) },\n  { id: \"xlsx\", labels: c({ \"en-gb\": \"XLSX\" }) },\n  { id: \"xml\", labels: c({ \"en-gb\": \"XML\" }) }\n], _e = (t = O) => {\n  const n = [];\n  for (const e of me) {\n    const r = N(e.labels, t);\n    n.push({ id: e.id, label: r ?? e.id });\n  }\n  return n;\n}, ye = [\n  { id: `\n`, labels: c({ \"en-gb\": \"Newline\" }) },\n  { id: \"\\r\", labels: c({ \"en-gb\": \"Carriage Return\" }) },\n  { id: `\\r\n`, labels: c({ \"en-gb\": \"Carriage Return/Newline\" }) }\n], Te = (t = O) => {\n  const n = [];\n  for (const e of ye) {\n    const r = N(e.labels, t);\n    n.push({ id: e.id, label: r ?? e.id });\n  }\n  return n;\n}, ge = [\n  { id: \":\", labels: c({ \"en-gb\": \"Colon\" }) },\n  { id: \",\", labels: c({ \"en-gb\": \"Comma\" }) },\n  { id: \"!\", labels: c({ \"en-gb\": \"Exclamation Mark\" }) },\n  // { id: '', label: { 'en-gb': 'Other' } }, // TODO: Maybe set this to a 'not printing' or special ascii character when there is a user supplied delimited, rather than ''?\n  { id: \"0x1E\", labels: c({ \"en-gb\": \"Record Separator\" }) },\n  { id: \";\", labels: c({ \"en-gb\": \"Semicolon\" }) },\n  { id: \" \", labels: c({ \"en-gb\": \"Space\" }) },\n  { id: \"\t\", labels: c({ \"en-gb\": \"Tab\" }) },\n  { id: \"_\", labels: c({ \"en-gb\": \"Underscore\" }) },\n  { id: \"0x1F\", labels: c({ \"en-gb\": \"Unit Separator\" }) },\n  { id: \"|\", labels: c({ \"en-gb\": \"Vertical Bar\" }) }\n], Ue = (t = O) => {\n  const n = [];\n  for (const e of ge) {\n    const r = N(e.labels, t);\n    n.push({ id: e.id, label: r ?? e.id });\n  }\n  return n;\n}, O = \"en-gb\";\nexport {\n  Ce as APIError,\n  C as ApplicationError,\n  Se as CONNECTOR_DESTINATION_OPERATIONS,\n  xe as CONNECTOR_SOURCE_OPERATIONS,\n  O as DEFAULT_LOCALE_CODE,\n  Oe as EngineError,\n  G as FetchError,\n  Me as OperationalError,\n  pe as VueError,\n  je as WindowPromiseRejectionError,\n  De as WindowRuntimeError,\n  we as buildFetchError,\n  he as componentConfigSchema,\n  Re as concatenateSerialisedErrorMessages,\n  Ee as connectorConfigSchema,\n  ke as contextConfigSchema,\n  ve as getComponentStatus,\n  _e as getDataFormats,\n  Te as getRecordDelimiters,\n  Ue as getValueDelimiters,\n  Ae as normalizeToError,\n  Le as presenterConfigSchema,\n  Ie as serialiseError,\n  Ne as useCytoscapeJS,\n  Pe as useDataTable\n};\n","const c = \"en-US\", s = /* @__PURE__ */ new Map();\nfunction f(e) {\n  switch (e) {\n    case \"Edm.Binary\":\n      return \"unknown\";\n    // Binary...\n    case \"Edm.Boolean\":\n      return \"boolean\";\n    case \"Edm.Byte\":\n      return \"wholeNumber\";\n    case \"Edm.DateTime\":\n      return \"moment\";\n    // DateTime...\n    case \"Edm.DateTimeOffset\":\n      return \"moment\";\n    // DateTimeOffset...\n    case \"Edm.Decimal\":\n      return \"decimalNumber\";\n    case \"Edm.Double\":\n      return \"decimalNumber\";\n    case \"Edm.Guid\":\n      return \"string\";\n    case \"Edm.Int16\":\n      return \"wholeNumber\";\n    case \"Edm.Int32\":\n      return \"wholeNumber\";\n    case \"Edm.Int64\":\n      return \"wholeNumber\";\n    case \"Edm.SByte\":\n      return \"wholeNumber\";\n    case \"Edm.Single\":\n      return \"decimalNumber\";\n    case \"Edm.String\":\n      return \"string\";\n    case \"Edm.Time\":\n      return \"momentTime\";\n    // Time...\n    default:\n      return \"unknown\";\n  }\n}\nfunction l(e) {\n  if (e) {\n    const t = e.lastIndexOf(\"/\"), n = e.lastIndexOf(\".\", t === -1 ? e.length : t);\n    return n === -1 ? e : e.slice(0, Math.max(0, n));\n  }\n}\nfunction m(e) {\n  if (e) {\n    const t = e.lastIndexOf(\".\");\n    if (t !== -1) return e.slice(Math.max(0, t + 1));\n  }\n}\nfunction r(e, t = 2, n = t, i = c) {\n  if (e == null) return \"\";\n  const u = `${i}decimal${t}.${n}`;\n  let a = s.get(u);\n  return a || (a = new Intl.NumberFormat(i, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: t,\n    minimumFractionDigits: n,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(u, a)), a.format(e);\n}\nfunction d(e) {\n  return e == null ? \"\" : e < 1e3 ? o(e) : e < 1e6 ? `${r(e / 1e3, 2, 0)}K` : e < 1e9 ? `${r(e / 1e6, 2, 0)}M` : e < 1e12 ? `${r(e / 1e9, 2, 0)}B` : `${r(e / 1e12, 2, 0)}T`;\n}\nfunction x(e) {\n  return e == null ? \"\" : e === 1 ? \"1 byte\" : e < 1024 ? `${o(e)} bytes` : e < 1048576 ? `${r(e / 1024, 2, 0)} KB` : e < 1073741824 ? `${r(e / 1048576, 2, 0)} MB` : e < 1099511627776 ? `${r(e / 1073741824, 2, 0)} GB` : `${r(e / 1099511627776, 2, 0)} TB`;\n}\nfunction p(e) {\n  return e == null ? \"\" : e < 1e3 ? `${o(e)} ms` : e === 1e3 ? `${o(e)} sec` : e < 6e4 ? `${r(e / 1e3, 2, 0)} secs` : e === 6e4 ? \"1 min\" : e < 36e5 ? `${r(e / 6e4, 2, 0)} mins` : e === 36e5 ? \"1 hr\" : e < 864e5 ? `${r(e / 36e5, 2, 0)} hrs` : e === 864e5 ? \"1 day\" : `${r(e / 864e5, 2, 0)} days`;\n}\nfunction o(e, t = c) {\n  if (e == null) return \"\";\n  const n = `${t}decimal0.0`;\n  let i = s.get(n);\n  return i || (i = new Intl.NumberFormat(t, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: 0,\n    minimumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(n, i)), i.format(e);\n}\nfunction E(e) {\n  switch (e) {\n    case \"csv\":\n      return \"text/csv\";\n    case \"tab\":\n    case \"tsv\":\n      return \"text/tab-separated-values\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\nexport {\n  f as convertODataTypeIdToUsageTypeId,\n  m as extractExtensionFromPath,\n  l as extractNameFromPath,\n  r as formatNumberAsDecimalNumber,\n  p as formatNumberAsDuration,\n  d as formatNumberAsSize,\n  x as formatNumberAsStorageSize,\n  o as formatNumberAsWholeNumber,\n  E as lookupMimeTypeForExtension\n};\n","// Dependencies - Framework\nimport type * as RustModule from '../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js';\n\n// Interfaces/Types\ntype RustBindings = typeof RustModule;\n\n// Module Variables\nlet rustBindingsPromise: Promise<RustBindings> | undefined;\n\n// Utilities\nasync function addNumbersWithRust(left: number, right: number): Promise<number> {\n    const { add_my_numbers } = await loadRustBindings();\n    console.log(1111, left, right);\n    const yyyy = add_my_numbers(Math.trunc(left), Math.trunc(right));\n    console.log(2222, yyyy);\n    return yyyy;\n}\n\n// Utilities\nasync function checksumWithRust(input: string): Promise<number> {\n    const { checksum_from_rust } = await loadRustBindings();\n    return checksum_from_rust(input);\n}\n\n// Helpers\nasync function loadRustBindings(): Promise<RustBindings> {\n    rustBindingsPromise ??= import('../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js');\n    return rustBindingsPromise;\n}\n\n// Exposures\nexport { addNumbersWithRust, checksumWithRust };\n","/*\n * File store emulator connector class.\n */\n\n// NOTE: Consider Cloudflare R2 Download URL: https://plugins-eu.datapositioning.app/connectors/datapos-connector-file-store-emulator-es.js. This would allow us to secure the bucket?\n\n/** Dependencies - Vendor. */\nimport { nanoid } from 'nanoid';\n\n/** Dependencies - Framework. */\nimport type { CSVParseTool } from '@datapos/datapos-tool-csv-parse';\nimport { buildFetchError, normalizeToError, OperationalError } from '@datapos/datapos-shared';\nimport type {\n    ConnectionConfig,\n    ConnectionNodeConfig,\n    Connector,\n    ConnectorConfig,\n    ConnectorTools,\n    FindResult,\n    FindSettings,\n    GetReadableStreamResult,\n    GetReadableStreamSettings,\n    ListResult,\n    ListSettings,\n    PreviewResult,\n    PreviewSettings,\n    RetrieveRecordsSettings,\n    RetrieveRecordsSummary,\n    ToolConfig\n} from '@datapos/datapos-shared';\nimport { extractExtensionFromPath, extractNameFromPath, lookupMimeTypeForExtension } from '@datapos/datapos-shared/utilities';\n\n/** Dependencies - Data. */\nimport config from '~/config.json';\nimport fileStoreIndex from '@/fileStoreIndex.json';\nimport { version } from '~/package.json';\nimport { addNumbersWithRust, checksumWithRust } from '@/rustBridge';\n\n/** Interfaces/Types - File store index. */\ntype FileStoreIndexItem =\n    | ({ typeId: 'folder'; childCount: number } & { name: string })\n    | ({ typeId: 'object'; id: string; lastModifiedAt: number; size: number } & { name: string });\ntype FileStoreIndex = Record<string, FileStoreIndexItem[]>;\n\n/** Constants */\nconst CALLBACK_PREVIEW_ABORTED = 'Connector failed to abort preview object operation.';\nconst CALLBACK_RETRIEVE_ABORTED = 'Connector failed to abort retrieve all records operation.';\nconst DEFAULT_PREVIEW_CHUNK_SIZE = 4096;\nconst DEFAULT_RETRIEVE_CHUNK_SIZE = 1000;\nconst URL_PREFIX = 'https://sample-data-eu.datapos.app';\n\n/** Classes - File store emulator connector. */\nexport default class FileStoreEmulatorConnector implements Connector {\n    abortController: AbortController | undefined;\n    readonly config: ConnectorConfig;\n    readonly connectionConfig: ConnectionConfig;\n    readonly tools: ConnectorTools;\n    readonly toolConfigs;\n\n    constructor(connectionConfig: ConnectionConfig, tools: ConnectorTools, toolConfigs: ToolConfig[]) {\n        this.abortController = undefined;\n        this.config = config as ConnectorConfig;\n        this.config.version = version;\n        this.connectionConfig = connectionConfig;\n        this.tools = tools;\n        this.toolConfigs = toolConfigs;\n    }\n\n    // Operations - Abort operation.\n    abortOperation(connector: FileStoreEmulatorConnector): void {\n        if (!connector.abortController) return;\n        connector.abortController.abort();\n        connector.abortController = undefined;\n    }\n\n    // Operations - Find object.\n    findObject(connector: FileStoreEmulatorConnector, settings: FindSettings): Promise<FindResult> {\n        // Loop through the file store index checking for an object entry with an identifier equal to the object name.\n        for (const folderPath in fileStoreIndex) {\n            if (Object.prototype.hasOwnProperty.call(fileStoreIndex, folderPath)) {\n                // eslint-disable-next-line security/detect-object-injection\n                const indexItems = (fileStoreIndex as FileStoreIndex)[folderPath];\n                const indexItem = indexItems?.find((indexItem) => indexItem.typeId === 'object' && indexItem.id === settings.objectName);\n                if (indexItem) return Promise.resolve({ folderPath }); // Found, return folder path.\n            }\n        }\n        return Promise.resolve({}); // Not found, return undefined folder path.\n    }\n\n    // Operations - Get readable stream.\n    async getReadableStream(connector: FileStoreEmulatorConnector, settings: GetReadableStreamSettings): Promise<GetReadableStreamResult> {\n        try {\n            console.log('getReader', 'connector', connector);\n            console.log('getReader', 'settings', settings);\n            // const response = await fetch('https://sample-data-eu.datapos.app/fileStore/ENGAGEMENT_START_EVENTS_202405121858.csv');\n            const response = await fetch('https://sample-data-eu.datapos.app/WDI_Data.csv');\n            console.log('getReader', 'response', response);\n            if (!response.body) throw new Error('ReadableStream not supported by this browser.');\n\n            const xxx = await addNumbersWithRust(12, 56);\n            const sum = await checksumWithRust(connector.config.version);\n            console.log('sum', sum, xxx);\n\n            return await Promise.resolve({ readable: response.body }); // Not found, return undefined folder path.\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - List nodes.\n    listNodes(connector: FileStoreEmulatorConnector, settings: ListSettings): Promise<ListResult> {\n        const indexItems = (fileStoreIndex as FileStoreIndex)[settings.folderPath] ?? [];\n        const connectionNodeConfigs: ConnectionNodeConfig[] = [];\n        for (const indexItem of indexItems) {\n            if (indexItem.typeId === 'folder') {\n                connectionNodeConfigs.push(this.constructFolderNodeConfig(settings.folderPath, indexItem.name, indexItem.childCount));\n            } else {\n                connectionNodeConfigs.push(this.constructObjectNodeConfig(settings.folderPath, indexItem.id, indexItem.name, indexItem.lastModifiedAt, indexItem.size));\n            }\n        }\n        return Promise.resolve({ cursor: undefined, isMore: false, connectionNodeConfigs, totalCount: connectionNodeConfigs.length });\n    }\n\n    // Operations - Preview object.\n    async previewObject(connector: FileStoreEmulatorConnector, settings: PreviewSettings): Promise<PreviewResult> {\n        try {\n            // Create an abort controller. Get the signal for the abort controller and add an abort listener.\n            connector.abortController = new AbortController();\n            const signal = connector.abortController.signal;\n            signal.addEventListener('abort', () => {\n                throw new OperationalError(CALLBACK_PREVIEW_ABORTED, 'datapos-connector-file-store-emulator|Connector|preview.abort');\n            });\n\n            // Fetch chunk from start of file.\n            const url = `${URL_PREFIX}/fileStore${settings.path}`;\n            const chunkSize = settings.chunkSize ?? DEFAULT_PREVIEW_CHUNK_SIZE;\n            const headers: HeadersInit = { Range: `bytes=0-${chunkSize}` };\n            const response = await fetch(encodeURI(url), { headers, signal });\n            if (response.ok) {\n                connector.abortController = undefined;\n                return { data: new Uint8Array(await response.arrayBuffer()), typeId: 'uint8Array' };\n            } else {\n                throw await buildFetchError(response, `Failed to fetch '${settings.path}' file.`, 'datapos-connector-file-store-emulator|Connector|preview');\n            }\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - Retrieve records.\n    async retrieveRecords(\n        connector: FileStoreEmulatorConnector,\n        settings: RetrieveRecordsSettings,\n        chunk: (records: string[][]) => void,\n        complete: (result: RetrieveRecordsSummary) => void\n    ): Promise<void> {\n        const csvParseTool = await connector.loadTool<CSVParseTool>('csv-parse');\n        console.log(1234, csvParseTool);\n        return new Promise((resolve, reject) => {\n            try {\n                // Create an abort controller and get the signal. Add an abort listener to the signal.\n                connector.abortController = new AbortController();\n                const signal = connector.abortController.signal;\n                signal.addEventListener(\n                    'abort',\n                    () => {\n                        connector.abortController = undefined;\n                        reject(new OperationalError(CALLBACK_RETRIEVE_ABORTED, 'datapos-connector-file-store-emulator|Connector|retrieve.abort'));\n                    },\n                    { once: true }\n                );\n\n                // Parser - Declare variables.\n                let pendingRows: string[][] = []; // Array to store rows of parsed field values and associated information.\n\n                // Parser - Create a parser object for CSV parsing.\n                const parser = csvParseTool.buildParser({\n                    delimiter: settings.valueDelimiterId,\n                    info: true,\n                    relax_column_count: true,\n                    relax_quotes: true\n                });\n\n                // Parser - Event listener for the 'readable' (data available) event.\n                parser.on('readable', () => {\n                    try {\n                        let data: string[] | null;\n                        while ((data = parser.read() as string[] | null) !== null) {\n                            signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                            pendingRows.push(data); // Append the row of parsed values and associated information to the pending rows array.\n                            if (pendingRows.length < DEFAULT_RETRIEVE_CHUNK_SIZE) continue; // Continue with next iteration if the pending rows array is not yet full.\n                            chunk(pendingRows); // Pass the pending rows to the engine using the 'chunk' callback.\n                            pendingRows = []; // Clear the pending rows array in preparation for the next batch of data.\n                        }\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Parser - Event listener for the 'error' event.\n                parser.on('error', (error) => {\n                    connector.abortController = undefined;\n                    reject(normalizeToError(error));\n                });\n\n                // Parser - Event listener for the 'end' (end of data) event.\n                parser.on('end', () => {\n                    try {\n                        signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                        connector.abortController = undefined; // Clear the abort controller.\n                        if (pendingRows.length > 0) {\n                            chunk(pendingRows);\n                            pendingRows = [];\n                        }\n                        complete({\n                            byteCount: parser.info.bytes,\n                            commentLineCount: parser.info.comment_lines,\n                            emptyLineCount: parser.info.empty_lines,\n                            invalidFieldLengthCount: parser.info.invalid_field_length,\n                            lineCount: parser.info.lines,\n                            recordCount: parser.info.records\n                        });\n                        resolve();\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Fetch, decode and forward the contents of the file to the parser.\n                const url = `${URL_PREFIX}/fileStore${settings.path}`;\n                fetch(encodeURI(url), { signal })\n                    .then(async (response) => {\n                        try {\n                            if (response.ok && response.body) {\n                                const stream = response.body.pipeThrough(new TextDecoderStream(settings.encodingId));\n                                const decodedStreamReader = stream.getReader();\n                                let result = await decodedStreamReader.read();\n                                while (!result.done) {\n                                    signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                                    // Write the decoded data to the parser and terminate if there is an error.\n                                    parser.write(result.value, (error) => {\n                                        if (error) {\n                                            connector.abortController = undefined;\n                                            reject(normalizeToError(error));\n                                        }\n                                    });\n                                    result = await decodedStreamReader.read();\n                                }\n                                parser.end(); // Signal no more data will be written.\n                            } else {\n                                const error = await connector.tools.dataPos.buildFetchError(\n                                    response,\n                                    `Failed to fetch '${settings.path}' file.`,\n                                    'datapos-connector-file-store-emulator|Connector|retrieve'\n                                );\n                                connector.abortController = undefined;\n                                reject(error);\n                            }\n                        } catch (error) {\n                            connector.abortController = undefined;\n                            reject(normalizeToError(error));\n                        }\n                    })\n                    .catch((error: unknown) => {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    });\n            } catch (error) {\n                connector.abortController = undefined;\n                reject(normalizeToError(error));\n            }\n        });\n    }\n\n    /** Utilities - Construct folder node configuration. */\n    private constructFolderNodeConfig(folderPath: string, name: string, childCount: number): ConnectionNodeConfig {\n        return { id: nanoid(), childCount, folderPath, label: name, name, typeId: 'folder' };\n    }\n\n    /** Utilities - Construct object (file) node configuration. */\n    private constructObjectNodeConfig(folderPath: string, id: string, fullName: string, lastModifiedAt: number, size: number): ConnectionNodeConfig {\n        const name = extractNameFromPath(fullName) ?? '';\n        const extension = extractExtensionFromPath(fullName);\n        const lastModifiedAtTimestamp = lastModifiedAt;\n        const mimeType = lookupMimeTypeForExtension(extension);\n        return { id, extension, folderPath, label: fullName, lastModifiedAt: lastModifiedAtTimestamp, mimeType, name, size, typeId: 'object' };\n    }\n\n    // Helpers - Load tool.\n    private async loadTool<T>(toolName: string): Promise<T> {\n        const fullName = `datapos-tool-${toolName}`;\n        const toolModuleConfig = this.toolConfigs.find((config) => config.id === fullName);\n        if (!toolModuleConfig) throw new Error(`Unknown tool '${toolName}'.`);\n\n        const url = `https://engine-eu.datapos.app/tools/${fullName}_v${toolModuleConfig.version}/${fullName}.es.js`;\n        const toolModule = (await import(/* @vite-ignore */ url)) as { T: new () => T };\n        const toolInstance = new toolModule.T();\n        return toolInstance;\n    }\n}\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","M","V","z","H","$","W","X","B","n","_","y","e","r","s","o","i","u","p","d","g","K","k","P","U","h","v","D","L","C","G","Me","we","Ae","c","l","t","m","E","rustBindingsPromise","addNumbersWithRust","left","right","add_my_numbers","loadRustBindings","yyyy","checksumWithRust","input","checksum_from_rust","CALLBACK_PREVIEW_ABORTED","CALLBACK_RETRIEVE_ABORTED","DEFAULT_PREVIEW_CHUNK_SIZE","DEFAULT_RETRIEVE_CHUNK_SIZE","URL_PREFIX","FileStoreEmulatorConnector","connectionConfig","tools","toolConfigs","config","version","connector","settings","folderPath","fileStoreIndex","indexItem","response","xxx","sum","error","indexItems","connectionNodeConfigs","signal","OperationalError","url","headers","buildFetchError","chunk","complete","csvParseTool","resolve","reject","pendingRows","parser","data","normalizeToError","decodedStreamReader","result","name","childCount","fullName","lastModifiedAt","extractNameFromPath","extension","extractExtensionFromPath","lastModifiedAtTimestamp","mimeType","lookupMimeTypeForExtension","toolName","toolModuleConfig","toolModule"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}