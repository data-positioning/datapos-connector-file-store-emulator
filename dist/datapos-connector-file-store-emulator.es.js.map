{"version":3,"file":"datapos-connector-file-store-emulator.es.js","sources":["../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../node_modules/@datapos/datapos-shared/dist/locale-CPeRw0Am.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-errors.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-utilities.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-tools.es.js","../src/rustBridge.ts","../src/index.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","let k;\n// @__NO_SIDE_EFFECTS__\nfunction I(n) {\n  return {\n    lang: n?.lang ?? k?.lang,\n    message: n?.message,\n    abortEarly: n?.abortEarly ?? k?.abortEarly,\n    abortPipeEarly: n?.abortPipeEarly ?? k?.abortPipeEarly\n  };\n}\nlet _;\n// @__NO_SIDE_EFFECTS__\nfunction A(n) {\n  return _?.get(n);\n}\nlet C;\n// @__NO_SIDE_EFFECTS__\nfunction O(n) {\n  return C?.get(n);\n}\nlet P;\n// @__NO_SIDE_EFFECTS__\nfunction G(n, t) {\n  return P?.get(n)?.get(t);\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(n) {\n  const t = typeof n;\n  return t === \"string\" ? `\"${n}\"` : t === \"number\" || t === \"bigint\" || t === \"boolean\" ? `${n}` : t === \"object\" || t === \"function\" ? (n && Object.getPrototypeOf(n)?.constructor?.name) ?? \"null\" : t;\n}\nfunction f(n, t, e, s, i) {\n  const r = i && \"input\" in i ? i.input : e.value, u = i?.expected ?? n.expects ?? null, a = i?.received ?? /* @__PURE__ */ D(r), l = {\n    kind: n.kind,\n    type: n.type,\n    input: r,\n    expected: u,\n    received: a,\n    message: `Invalid ${t}: ${u ? `Expected ${u} but r` : \"R\"}eceived ${a}`,\n    requirement: n.requirement,\n    path: i?.path,\n    issues: i?.issues,\n    lang: s.lang,\n    abortEarly: s.abortEarly,\n    abortPipeEarly: s.abortPipeEarly\n  }, c = n.kind === \"schema\", p = i?.message ?? n.message ?? /* @__PURE__ */ G(n.reference, l.lang) ?? (c ? /* @__PURE__ */ O(l.lang) : null) ?? s.message ?? /* @__PURE__ */ A(l.lang);\n  p !== void 0 && (l.message = typeof p == \"function\" ? p(l) : p), c && (e.typed = !1), e.issues ? e.issues.push(l) : e.issues = [l];\n}\n// @__NO_SIDE_EFFECTS__\nfunction y(n) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(t) {\n      return n[\"~run\"]({ value: t }, /* @__PURE__ */ I());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction w(n, t) {\n  return Object.hasOwn(n, t) && t !== \"__proto__\" && t !== \"prototype\" && t !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction L(n, t) {\n  const e = [...new Set(n)];\n  return e.length > 1 ? `(${e.join(` ${t} `)})` : e[0] ?? \"never\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction F(n, t, e) {\n  return typeof n.fallback == \"function\" ? n.fallback(t, e) : n.fallback;\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(n, t, e) {\n  return typeof n.default == \"function\" ? n.default(t, e) : n.default;\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: R,\n    expects: \"Array\",\n    async: !1,\n    item: n,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      const i = e.value;\n      if (Array.isArray(i)) {\n        e.typed = !0, e.value = [];\n        for (let r = 0; r < i.length; r++) {\n          const u = i[r], a = this.item[\"~run\"]({ value: u }, s);\n          if (a.issues) {\n            const l = {\n              type: \"array\",\n              origin: \"value\",\n              input: i,\n              key: r,\n              value: u\n            };\n            for (const c of a.issues)\n              c.path ? c.path.unshift(l) : c.path = [l], e.issues?.push(c);\n            if (e.issues || (e.issues = a.issues), s.abortEarly) {\n              e.typed = !1;\n              break;\n            }\n          }\n          a.typed || (e.typed = !1), e.value.push(a.value);\n        }\n      } else f(this, \"type\", e, s);\n      return e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(n) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: U,\n    expects: \"boolean\",\n    async: !1,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(t, e) {\n      return typeof t.value == \"boolean\" ? t.typed = !0 : f(this, \"type\", t, e), t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction M(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: M,\n    expects: /* @__PURE__ */ D(n),\n    async: !1,\n    literal: n,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      return e.value === this.literal ? e.typed = !0 : f(this, \"type\", e, s), e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: v,\n    expects: `(${n.expects} | null)`,\n    async: !1,\n    wrapped: n,\n    default: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      return e.value === null && (this.default !== void 0 && (e.value = /* @__PURE__ */ x(this, e, s)), e.value === null) ? (e.typed = !0, e) : this.wrapped[\"~run\"](e, s);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction m(n) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: m,\n    expects: \"number\",\n    async: !1,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(t, e) {\n      return typeof t.value == \"number\" && !isNaN(t.value) ? t.typed = !0 : f(this, \"type\", t, e), t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: d,\n    expects: \"Object\",\n    async: !1,\n    entries: n,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      const i = e.value;\n      if (i && typeof i == \"object\") {\n        e.typed = !0, e.value = {};\n        for (const r in this.entries) {\n          const u = this.entries[r];\n          if (r in i || (u.type === \"exact_optional\" || u.type === \"optional\" || u.type === \"nullish\") && u.default !== void 0) {\n            const a = r in i ? i[r] : /* @__PURE__ */ x(u), l = u[\"~run\"]({ value: a }, s);\n            if (l.issues) {\n              const c = {\n                type: \"object\",\n                origin: \"value\",\n                input: i,\n                key: r,\n                value: a\n              };\n              for (const p of l.issues)\n                p.path ? p.path.unshift(c) : p.path = [c], e.issues?.push(p);\n              if (e.issues || (e.issues = l.issues), s.abortEarly) {\n                e.typed = !1;\n                break;\n              }\n            }\n            l.typed || (e.typed = !1), e.value[r] = l.value;\n          } else if (u.fallback !== void 0) e.value[r] = /* @__PURE__ */ F(u);\n          else if (u.type !== \"exact_optional\" && u.type !== \"optional\" && u.type !== \"nullish\" && (f(this, \"key\", e, s, {\n            input: void 0,\n            expected: `\"${r}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input: i,\n              key: r,\n              value: i[r]\n            }]\n          }), s.abortEarly))\n            break;\n        }\n      } else f(this, \"type\", e, s);\n      return e;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction b(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: b,\n    expects: `(${n.expects} | undefined)`,\n    async: !1,\n    wrapped: n,\n    default: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      return e.value === void 0 && (this.default !== void 0 && (e.value = /* @__PURE__ */ x(this, e, s)), e.value === void 0) ? (e.typed = !0, e) : this.wrapped[\"~run\"](e, s);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(n, t, e) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: n,\n    value: t,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(s, i) {\n      const r = s.value;\n      if (r && typeof r == \"object\") {\n        s.typed = !0, s.value = {};\n        for (const u in r) if (/* @__PURE__ */ w(r, u)) {\n          const a = r[u], l = this.key[\"~run\"]({ value: u }, i);\n          if (l.issues) {\n            const p = {\n              type: \"object\",\n              origin: \"key\",\n              input: r,\n              key: u,\n              value: a\n            };\n            for (const h of l.issues)\n              h.path = [p], s.issues?.push(h);\n            if (s.issues || (s.issues = l.issues), i.abortEarly) {\n              s.typed = !1;\n              break;\n            }\n          }\n          const c = this.value[\"~run\"]({ value: a }, i);\n          if (c.issues) {\n            const p = {\n              type: \"object\",\n              origin: \"value\",\n              input: r,\n              key: u,\n              value: a\n            };\n            for (const h of c.issues)\n              h.path ? h.path.unshift(p) : h.path = [p], s.issues?.push(h);\n            if (s.issues || (s.issues = c.issues), i.abortEarly) {\n              s.typed = !1;\n              break;\n            }\n          }\n          (!l.typed || !c.typed) && (s.typed = !1), l.typed && (s.value[l.value] = c.value);\n        }\n      } else f(this, \"type\", s, i);\n      return s;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction o(n) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: o,\n    expects: \"string\",\n    async: !1,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(t, e) {\n      return typeof t.value == \"string\" ? t.typed = !0 : f(this, \"type\", t, e), t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(n) {\n  let t;\n  if (n) for (const e of n) t ? t.push(...e.issues) : t = e.issues;\n  return t;\n}\n// @__NO_SIDE_EFFECTS__\nfunction j(n, t) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: j,\n    expects: /* @__PURE__ */ L(n.map((e) => e.expects), \"|\"),\n    async: !1,\n    options: n,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ y(this);\n    },\n    \"~run\"(e, s) {\n      let i, r, u;\n      for (const a of this.options) {\n        const l = a[\"~run\"]({ value: e.value }, s);\n        if (l.typed) if (l.issues) r ? r.push(l) : r = [l];\n        else {\n          i = l;\n          break;\n        }\n        else u ? u.push(l) : u = [l];\n      }\n      if (i) return i;\n      if (r) {\n        if (r.length === 1) return r[0];\n        f(this, \"type\", e, s, { issues: /* @__PURE__ */ S(r) }), e.typed = !0;\n      } else {\n        if (u?.length === 1) return u[0];\n        f(this, \"type\", e, s, { issues: /* @__PURE__ */ S(u) });\n      }\n      return e;\n    }\n  };\n}\nconst E = (n) => /* @__PURE__ */ j(n.map((t) => /* @__PURE__ */ M(t))), Q = /* @__PURE__ */ d({\n  \"en-au\": /* @__PURE__ */ o(),\n  \"en-gb\": /* @__PURE__ */ o(),\n  \"en-us\": /* @__PURE__ */ o(),\n  \"es-es\": /* @__PURE__ */ o()\n}), g = /* @__PURE__ */ d({\n  \"en-au\": /* @__PURE__ */ b(/* @__PURE__ */ o()),\n  \"en-gb\": /* @__PURE__ */ b(/* @__PURE__ */ o()),\n  \"en-us\": /* @__PURE__ */ b(/* @__PURE__ */ o()),\n  \"es-es\": /* @__PURE__ */ b(/* @__PURE__ */ o())\n}), q = E([\"amber\", \"green\", \"red\", \"other\"]), K = E([\n  \"alpha\",\n  \"beta\",\n  \"generalAvailability\",\n  \"notApplicable\",\n  \"preAlpha\",\n  \"proposed\",\n  \"releaseCandidate\",\n  \"unavailable\",\n  \"underReview\"\n]), N = E([\n  \"app\",\n  \"connector\",\n  \"connectorConnection\",\n  \"context\",\n  \"contextModelGroup\",\n  \"contextModel\",\n  \"contextModelDimensionGroup\",\n  \"contextModelDimension\",\n  \"contextModelDimensionHierarchy\",\n  \"contextModelEntityGroup\",\n  \"contextModelEntity\",\n  \"contextModelEntityDataItem\",\n  \"contextModelEntityEvent\",\n  \"contextModelEntityPrimaryMeasure\",\n  \"contextModelSecondaryMeasureGroup\",\n  \"contextModelSecondaryMeasure\",\n  \"dataView\",\n  \"dimension\",\n  \"engine\",\n  \"eventQuery\",\n  \"presenter\",\n  \"presenterPresentation\",\n  \"tool\"\n]), T = /* @__PURE__ */ d({\n  id: /* @__PURE__ */ o(),\n  color: q,\n  label: /* @__PURE__ */ o()\n}), H = {\n  id: /* @__PURE__ */ o(),\n  label: g,\n  description: g,\n  firstCreatedAt: /* @__PURE__ */ b(/* @__PURE__ */ m()),\n  icon: /* @__PURE__ */ v(/* @__PURE__ */ o()),\n  iconDark: /* @__PURE__ */ v(/* @__PURE__ */ o()),\n  lastUpdatedAt: /* @__PURE__ */ v(/* @__PURE__ */ m()),\n  status: /* @__PURE__ */ v(T),\n  statusId: K\n}, z = /* @__PURE__ */ d({\n  ...H,\n  typeId: N\n}), B = /* @__PURE__ */ d({\n  id: /* @__PURE__ */ o(),\n  label: g,\n  description: g,\n  icon: /* @__PURE__ */ v(/* @__PURE__ */ o()),\n  iconDark: /* @__PURE__ */ v(/* @__PURE__ */ o()),\n  order: /* @__PURE__ */ m(),\n  path: /* @__PURE__ */ o()\n}), J = \"en-gb\";\nexport {\n  J as D,\n  H as a,\n  R as b,\n  z as c,\n  M as d,\n  b as e,\n  m as f,\n  Q as g,\n  U as h,\n  B as i,\n  E as l,\n  v as n,\n  d as o,\n  g as p,\n  V as r,\n  o as s\n};\n","import { l as d, o as r, b as s, d as i, f as m, a as p, i as b, D as a } from \"./locale-CPeRw0Am.js\";\nimport { m as g } from \"./moduleConfig.schema-ElDY1bZx.js\";\nconst u = d([\"list\"]), f = r({\n  ...p,\n  typeId: i(\"contextModelGroup\"),\n  modelRefs: s(b),\n  order: m()\n}), v = r({\n  ...g,\n  typeId: i(\"context\"),\n  models: s(f),\n  operations: s(u)\n}), C = d([\"list\", \"render\", \"setColorMode\"]), y = r({\n  ...g,\n  typeId: i(\"presenter\"),\n  presentations: s(b),\n  operations: s(C)\n});\nfunction F() {\n  return { render: S };\n}\nfunction S(t, o, n) {\n  n.textContent = \"Cytoscape.js diagram goes here...\";\n}\nfunction M() {\n  return { render: x };\n}\nfunction x(t, o) {\n  console.log(1111, t), console.log(2222, o), console.log(3333, o.childNodes), console.log(4444, o.children);\n}\nconst e = (t) => new Map(Object.entries(t)), c = (t, o, n = a) => {\n  const l = t.get(o);\n  if (l !== void 0) return l;\n  if (n !== o)\n    return t.get(n);\n}, D = [\n  { id: \"dtv\", labels: e({ \"en-gb\": \"Delimited Text\" }) },\n  { id: \"e/e\", labels: e({ \"en-gb\": \"Entity/Event\" }) },\n  { id: \"json\", labels: e({ \"en-gb\": \"JSON\" }) },\n  { id: \"spss\", labels: e({ \"en-gb\": \"SPSS\" }) },\n  { id: \"xls\", labels: e({ \"en-gb\": \"XLS\" }) },\n  { id: \"xlsx\", labels: e({ \"en-gb\": \"XLSX\" }) },\n  { id: \"xml\", labels: e({ \"en-gb\": \"XML\" }) }\n], O = (t = a) => {\n  const o = [];\n  for (const n of D) {\n    const l = c(n.labels, t);\n    o.push({ id: n.id, label: l ?? n.id });\n  }\n  return o;\n}, E = [\n  { id: `\n`, labels: e({ \"en-gb\": \"Newline\" }) },\n  { id: \"\\r\", labels: e({ \"en-gb\": \"Carriage Return\" }) },\n  { id: `\\r\n`, labels: e({ \"en-gb\": \"Carriage Return/Newline\" }) }\n], _ = (t = a) => {\n  const o = [];\n  for (const n of E) {\n    const l = c(n.labels, t);\n    o.push({ id: n.id, label: l ?? n.id });\n  }\n  return o;\n}, L = [\n  { id: \":\", labels: e({ \"en-gb\": \"Colon\" }) },\n  { id: \",\", labels: e({ \"en-gb\": \"Comma\" }) },\n  { id: \"!\", labels: e({ \"en-gb\": \"Exclamation Mark\" }) },\n  // { id: '', label: { 'en-gb': 'Other' } }, // TODO: Maybe set this to a 'not printing' or special ascii character when there is a user supplied delimited, rather than ''?\n  { id: \"0x1E\", labels: e({ \"en-gb\": \"Record Separator\" }) },\n  { id: \";\", labels: e({ \"en-gb\": \"Semicolon\" }) },\n  { id: \" \", labels: e({ \"en-gb\": \"Space\" }) },\n  { id: \"\t\", labels: e({ \"en-gb\": \"Tab\" }) },\n  { id: \"_\", labels: e({ \"en-gb\": \"Underscore\" }) },\n  { id: \"0x1F\", labels: e({ \"en-gb\": \"Unit Separator\" }) },\n  { id: \"|\", labels: e({ \"en-gb\": \"Vertical Bar\" }) }\n], T = [\",\", \";\", \"\t\", \"|\", \" \", \":\", \"_\", \"!\", \"0x1F\", \"0x1E\"], U = (t = a) => {\n  const o = [];\n  for (const n of L) {\n    const l = c(n.labels, t);\n    o.push({ id: n.id, label: l ?? n.id });\n  }\n  return o;\n};\nexport {\n  T as ORDERED_VALUE_DELIMITER_IDS,\n  v as contextConfigSchema,\n  O as getDataFormats,\n  _ as getRecordDelimiters,\n  U as getValueDelimiters,\n  y as presenterConfigSchema,\n  F as useCytoscapeJS,\n  M as useDataTable\n};\n","class i extends Error {\n  locator;\n  /** Logical source of the error. */\n  constructor(o, t, r) {\n    super(o, r), this.name = new.target.name, this.locator = t;\n  }\n}\nclass a extends i {\n}\nclass g extends a {\n}\nclass p extends a {\n}\nclass c extends a {\n  body;\n  /** Sanitized HTTP response body. */\n  constructor(o, t, r, n) {\n    super(o, t, n), this.name = new.target.name, this.body = E(r ?? void 0);\n  }\n}\nclass y extends i {\n}\nclass m extends a {\n  componentName;\n  /** Vue component name, if available. */\n  info;\n  /** Vue error info string. */\n  constructor(o, t, r, n, s) {\n    super(o, t, s), this.name = new.target.name, this.info = r, this.componentName = n;\n  }\n}\nclass w extends a {\n}\nclass h extends a {\n}\nasync function b(e, o, t) {\n  const r = ` - ${e.statusText}`, n = `${o} Response status '${e.status}${e.statusText ? r : \"\"}' received.`;\n  let s;\n  try {\n    s = await e.text();\n  } catch (d) {\n    s = `<body unavailable: ${l(d).message}>`;\n  }\n  return new c(n, t, s);\n}\nfunction k(e) {\n  return e.map((o) => o.message).join(\" \");\n}\nfunction x(e) {\n  try {\n    e();\n  } catch {\n  }\n}\nfunction l(e) {\n  if (e instanceof Error) return e;\n  if (typeof e == \"string\") return new Error(e);\n  if (typeof e == \"number\" || typeof e == \"boolean\" || typeof e == \"bigint\") return new Error(String(e));\n  if (typeof e == \"symbol\") return new Error(e.description ?? \"Unknown error\");\n  if (e != null && typeof e == \"object\")\n    try {\n      return new Error(JSON.stringify(e));\n    } catch {\n      return new Error(\"Unknown error\");\n    }\n  return new Error(\"Unknown error\");\n}\nfunction R(e) {\n  const o = /* @__PURE__ */ new Set(), t = [];\n  let r = e;\n  for (; r != null && !o.has(r); ) {\n    o.add(r);\n    let n;\n    if (r instanceof c)\n      n = { componentName: void 0, body: r.body, info: void 0, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof m)\n      n = {\n        componentName: r.componentName,\n        body: void 0,\n        info: r.info,\n        locator: r.locator,\n        message: r.message,\n        name: r.name,\n        stack: r.stack\n      }, r = r.cause;\n    else if (r instanceof i)\n      n = { componentName: void 0, body: void 0, info: void 0, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof Error) {\n      const s = r;\n      n = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: s.message, name: s.name, stack: s.stack }, r = s.cause;\n    } else\n      n = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: f(r), name: \"Error\", stack: void 0 }, r = void 0;\n    /(?:\\.{3}|[.!?])$/.test(n.message) || (n.message += \".\"), t.push(n);\n  }\n  return t;\n}\nfunction f(e) {\n  let o;\n  try {\n    o = JSON.stringify(e);\n  } catch {\n    typeof e == \"symbol\" ? o = e.description ?? \"Unknown error\" : typeof e == \"bigint\" ? o = e.toString() : o = \"Unknown error\";\n  }\n  return o === \"\" && (o = \"Unknown error\"), o;\n}\nfunction E(e) {\n  if (!(e == null || e === \"\"))\n    return e.length > 2048 ? `${e.slice(0, 2048)}... [truncated]` : e;\n}\nexport {\n  g as APIError,\n  a as ApplicationError,\n  p as EngineError,\n  c as FetchError,\n  y as OperationalError,\n  m as VueHandledError,\n  h as WindowHandledPromiseRejectionError,\n  w as WindowHandledRuntimeError,\n  b as buildFetchError,\n  k as concatenateSerialisedErrorMessages,\n  x as ignoreErrors,\n  l as normalizeToError,\n  R as serialiseError\n};\n","const c = \"en-US\", s = /* @__PURE__ */ new Map();\nfunction f(e) {\n  switch (e) {\n    case \"Edm.Binary\":\n      return \"unknown\";\n    // Binary...\n    case \"Edm.Boolean\":\n      return \"boolean\";\n    case \"Edm.Byte\":\n      return \"wholeNumber\";\n    case \"Edm.DateTime\":\n      return \"moment\";\n    // DateTime...\n    case \"Edm.DateTimeOffset\":\n      return \"moment\";\n    // DateTimeOffset...\n    case \"Edm.Decimal\":\n      return \"decimalNumber\";\n    case \"Edm.Double\":\n      return \"decimalNumber\";\n    case \"Edm.Guid\":\n      return \"string\";\n    case \"Edm.Int16\":\n      return \"wholeNumber\";\n    case \"Edm.Int32\":\n      return \"wholeNumber\";\n    case \"Edm.Int64\":\n      return \"wholeNumber\";\n    case \"Edm.SByte\":\n      return \"wholeNumber\";\n    case \"Edm.Single\":\n      return \"decimalNumber\";\n    case \"Edm.String\":\n      return \"string\";\n    case \"Edm.Time\":\n      return \"momentTime\";\n    // Time...\n    default:\n      return \"unknown\";\n  }\n}\nfunction l(e) {\n  if (e) {\n    const t = e.lastIndexOf(\"/\"), n = e.lastIndexOf(\".\", t === -1 ? e.length : t);\n    return n === -1 ? e : e.slice(0, Math.max(0, n));\n  }\n}\nfunction m(e) {\n  if (e) {\n    const t = e.lastIndexOf(\".\");\n    if (t !== -1) return e.slice(Math.max(0, t + 1));\n  }\n}\nfunction r(e, t = 2, n = t, i = c) {\n  if (e == null) return \"\";\n  const u = `${i}decimal${t}.${n}`;\n  let a = s.get(u);\n  return a || (a = new Intl.NumberFormat(i, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: t,\n    minimumFractionDigits: n,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(u, a)), a.format(e);\n}\nfunction d(e) {\n  return e == null ? \"\" : e < 1e3 ? o(e) : e < 1e6 ? `${r(e / 1e3, 2, 0)}K` : e < 1e9 ? `${r(e / 1e6, 2, 0)}M` : e < 1e12 ? `${r(e / 1e9, 2, 0)}B` : `${r(e / 1e12, 2, 0)}T`;\n}\nfunction x(e) {\n  return e == null ? \"\" : e === 1 ? \"1 byte\" : e < 1024 ? `${o(e)} bytes` : e < 1048576 ? `${r(e / 1024, 2, 0)} KB` : e < 1073741824 ? `${r(e / 1048576, 2, 0)} MB` : e < 1099511627776 ? `${r(e / 1073741824, 2, 0)} GB` : `${r(e / 1099511627776, 2, 0)} TB`;\n}\nfunction p(e) {\n  return e == null ? \"\" : e < 1e3 ? `${o(e)} ms` : e === 1e3 ? `${o(e)} sec` : e < 6e4 ? `${r(e / 1e3, 2, 0)} secs` : e === 6e4 ? \"1 min\" : e < 36e5 ? `${r(e / 6e4, 2, 0)} mins` : e === 36e5 ? \"1 hr\" : e < 864e5 ? `${r(e / 36e5, 2, 0)} hrs` : e === 864e5 ? \"1 day\" : `${r(e / 864e5, 2, 0)} days`;\n}\nfunction o(e, t = c) {\n  if (e == null) return \"\";\n  const n = `${t}decimal0.0`;\n  let i = s.get(n);\n  return i || (i = new Intl.NumberFormat(t, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: 0,\n    minimumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(n, i)), i.format(e);\n}\nfunction E(e) {\n  switch (e) {\n    case \"csv\":\n      return \"text/csv\";\n    case \"tab\":\n    case \"tsv\":\n      return \"text/tab-separated-values\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\nexport {\n  f as convertODataTypeIdToUsageTypeId,\n  m as extractExtensionFromPath,\n  l as extractNameFromPath,\n  r as formatNumberAsDecimalNumber,\n  p as formatNumberAsDuration,\n  d as formatNumberAsSize,\n  x as formatNumberAsStorageSize,\n  o as formatNumberAsWholeNumber,\n  E as lookupMimeTypeForExtension\n};\n","async function a(e, o) {\n  const n = `datapos-tool-${o}`, t = e.find((r) => r.id === n);\n  if (!t) throw new Error(`Connector could not load unknown tool '${o}'.`);\n  const l = await import(`https://engine-eu.datapos.app/tools/${o}_v${t.version}/${n}.es.js`);\n  return new l.Tool();\n}\nexport {\n  a as loadTool\n};\n","// Dependencies - Framework\nimport type * as RustModule from '../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js';\n\n// Interfaces/Types\ntype RustBindings = typeof RustModule;\n\n// Module Variables\nlet rustBindingsPromise: Promise<RustBindings> | undefined;\n\n// Utilities\nasync function addNumbersWithRust(left: number, right: number): Promise<number> {\n    const { add_my_numbers } = await loadRustBindings();\n    console.log(1111, left, right);\n    const yyyy = add_my_numbers(Math.trunc(left), Math.trunc(right));\n    console.log(2222, yyyy);\n    return yyyy;\n}\n\n// Utilities\nasync function checksumWithRust(input: string): Promise<number> {\n    const { checksum_from_rust } = await loadRustBindings();\n    return checksum_from_rust(input);\n}\n\n// Helpers\nasync function loadRustBindings(): Promise<RustBindings> {\n    rustBindingsPromise ??= import('../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js');\n    return rustBindingsPromise;\n}\n\n// Exposures\nexport { addNumbersWithRust, checksumWithRust };\n","/**\n * File store emulator connector class.\n */\n\n/* TODO: Consider Cloudflare R2 Download URL: https://plugins-eu.datapositioning.app/connectors/datapos-connector-file-store-emulator-es.js.\n   This would allow us to secure the bucket? */\n\n// Vendor dependencies.\nimport { nanoid } from 'nanoid';\n\n// Framework dependencies.\nimport type { Tool as CSVParseTool } from '@datapos/datapos-tool-csv-parse';\nimport type { DataViewPreviewConfig } from '@datapos/datapos-shared';\nimport type { Tool as FileOperatorsTool } from '@datapos/datapos-tool-file-operators';\nimport { ORDERED_VALUE_DELIMITER_IDS } from '@datapos/datapos-shared';\nimport { buildFetchError, normalizeToError, OperationalError } from '@datapos/datapos-shared/errors';\nimport type {\n    ConnectionNodeConfig,\n    ConnectorConfig,\n    ConnectorInterface,\n    FindObjectFolderPathOptions,\n    GetReadableStreamOptions,\n    ListNodesOptions,\n    ListNodesResult,\n    PreviewObjectOptions,\n    RetrieveRecordsOptions,\n    RetrieveRecordsSummary\n} from '@datapos/datapos-shared/component/connector';\nimport { extractExtensionFromPath, extractNameFromPath, lookupMimeTypeForExtension } from '@datapos/datapos-shared/utilities';\nimport { loadTool, type ToolConfig } from '@datapos/datapos-shared/component/tool';\n\n// Data dependencies.\nimport config from '~/config.json';\nimport fileStoreFolderPathData from '@/fileStoreFolderPaths.json';\nimport { addNumbersWithRust, checksumWithRust } from '@/rustBridge';\n\n/**\n * File store folder paths.\n */\ntype FileStoreFolderNode =\n    | ({ typeId: 'folder'; childCount: number } & { name: string })\n    | ({ typeId: 'object'; id: string; lastModifiedAt: number; size: number } & { name: string });\ntype FileStoreFolderPaths = Record<string, FileStoreFolderNode[]>;\n\n// Constants.\nconst URL_PREFIX = 'https://sample-data-eu.datapos.app';\n\n/**\n * File store emulator connector.\n */\nclass Connector implements ConnectorInterface {\n    abortController: AbortController | undefined;\n    readonly config: ConnectorConfig;\n    readonly toolConfigs;\n\n    constructor(toolConfigs: ToolConfig[]) {\n        this.abortController = undefined;\n        this.config = config as ConnectorConfig;\n        this.toolConfigs = toolConfigs;\n    }\n\n    //━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n    //#region: Operations.\n\n    /**\n     * Abort the currently running operation.\n     */\n    abortOperation(connector: ConnectorInterface): void {\n        if (!connector.abortController) return;\n        connector.abortController.abort();\n        connector.abortController = undefined;\n    }\n\n    /**\n     * Find the folder path containing the specified object node.\n     */\n    findObjectFolderPath(connector: ConnectorInterface, options: FindObjectFolderPathOptions): Promise<string | null> {\n        const fileStoreFolderPaths = fileStoreFolderPathData as FileStoreFolderPaths;\n        // Loop through the folder path data checking for an object entry with an identifier equal to the object name.\n        for (const folderPath in fileStoreFolderPaths) {\n            if (Object.hasOwn(fileStoreFolderPaths, folderPath)) {\n                // eslint-disable-next-line security/detect-object-injection\n                const folderPathNodes = fileStoreFolderPaths[folderPath];\n                const folderPathNode = folderPathNodes?.find((folderPathNode) => folderPathNode.typeId === 'object' && folderPathNode.id === options.nodeId);\n                if (folderPathNode) return Promise.resolve(folderPath); // Found, return folder path.\n            }\n        }\n        return Promise.resolve(null); // Not found.\n    }\n\n    /**\n     * Get a readable stream for the specified object node path.\n     */\n    async getReadableStream(connector: ConnectorInterface, options: GetReadableStreamOptions): Promise<ReadableStream<Uint8Array>> {\n        // Create an abort controller and extract its signal.\n        const { signal } = (connector.abortController = new AbortController());\n\n        try {\n            const response = await fetch(`${URL_PREFIX}/fileStore${options.path}`, { signal });\n            if (!response.ok) {\n                throw await buildFetchError(response, `Failed to fetch '${options.path}' file.`, 'datapos-connector-file-store-emulator|Connector|getReadableStream');\n            }\n            if (response.body == null) {\n                throw new OperationalError('Readable streams are not supported in this runtime.', 'datapos-connector-file-store-emulator|Connector|getReadableStream.unsupported');\n            }\n\n            // TODO: Remove after testing.\n            const xxx = await addNumbersWithRust(12, 56);\n            const sum = await checksumWithRust(connector.config.version);\n            console.log('sum', sum, xxx);\n\n            return await Promise.resolve(response.body);\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            connector.abortController = undefined;\n        }\n    }\n\n    /**\n     * Lists all nodes (folders and objects) in the specified folder path.\n     */\n    listNodes(connector: ConnectorInterface, options: ListNodesOptions): Promise<ListNodesResult> {\n        const fileStoreFolderPaths = fileStoreFolderPathData as FileStoreFolderPaths;\n        const folderNodes = fileStoreFolderPaths[options.folderPath] ?? [];\n        const connectionNodeConfigs: ConnectionNodeConfig[] = [];\n        for (const folderNode of folderNodes) {\n            if (folderNode.typeId === 'folder') {\n                connectionNodeConfigs.push(constructFolderNodeConfig(options.folderPath, folderNode.name, folderNode.childCount));\n            } else {\n                connectionNodeConfigs.push(constructObjectNodeConfig(options.folderPath, folderNode.id, folderNode.name, folderNode.lastModifiedAt, folderNode.size));\n            }\n        }\n        return Promise.resolve({ cursor: undefined, isMore: false, connectionNodeConfigs, totalCount: connectionNodeConfigs.length });\n    }\n\n    /**\n     * Preview the contents of the object node with the specified path.\n     */\n    async previewObject(connector: ConnectorInterface, options: PreviewObjectOptions): Promise<DataViewPreviewConfig> {\n        // Create an abort controller and extract its signal.\n        const { signal } = (connector.abortController = new AbortController());\n\n        try {\n            const asAt = Date.now();\n            const startedAt = performance.now();\n\n            const fileOperatorsTool = await loadTool<FileOperatorsTool>(connector.toolConfigs, 'file-operators');\n            const previewConfig = await fileOperatorsTool.previewFile(`${URL_PREFIX}/fileStore${options.path}`, signal, options.chunkSize);\n\n            if (previewConfig.dataFormatId == null) throw new Error('Connector unable to process files of this type.');\n            if (previewConfig.text == null) {\n                throw new Error('File is empty.');\n            }\n\n            const csvParseTool = await loadTool<CSVParseTool>(connector.toolConfigs, 'csv-parse');\n            const schemaConfig = await csvParseTool.determineSchemaConfig(previewConfig.text, ORDERED_VALUE_DELIMITER_IDS);\n\n            const duration = performance.now() - startedAt;\n            return {\n                asAt,\n                columnConfigs: [],\n                dataFormatId: previewConfig.dataFormatId,\n                duration,\n                encodingId: previewConfig.encodingId,\n                encodingConfidenceLevel: previewConfig.encodingConfidenceLevel,\n                fileType: previewConfig.fileTypeConfig,\n                hasHeaders: undefined,\n                recordDelimiterId: schemaConfig.recordDelimiterId,\n                records: [],\n                size: previewConfig.bytes.length,\n                text: previewConfig.text,\n                valueDelimiterId: schemaConfig.valueDelimiterId\n            };\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            connector.abortController = undefined;\n        }\n    }\n    /**\n     * Retrieves all records from a CSV object node using streaming and chunked processing.\n     */\n    async retrieveRecords(\n        connector: ConnectorInterface,\n        options: RetrieveRecordsOptions,\n        chunk: (records: (string[] | Record<string, unknown>)[]) => void,\n        complete: (result: RetrieveRecordsSummary) => void\n    ): Promise<void> {\n        connector.abortController = new AbortController();\n\n        try {\n            const csvParseTool = await loadTool<CSVParseTool>(connector.toolConfigs, 'csv-parse');\n            const parseStreamOptions = { delimiter: options.valueDelimiterId, info: true, relax_column_count: true, relax_quotes: true };\n            const url = `${URL_PREFIX}/fileStore${options.path}`;\n            const summary = await csvParseTool.parseStream(options, parseStreamOptions, url, connector.abortController, chunk);\n            complete(summary);\n        } catch (error) {\n            throw normalizeToError(error);\n        } finally {\n            connector.abortController = undefined;\n        }\n    }\n\n    //#endregion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n}\n\n//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n//#region: Helpers.\n\n/**\n * Construct folder node configuration.\n */\nfunction constructFolderNodeConfig(folderPath: string, name: string, childCount: number): ConnectionNodeConfig {\n    return { id: nanoid(), childCount, extension: undefined, folderPath, label: name, name, typeId: 'folder' };\n}\n\n/**\n * Construct object (file) node configuration.\n */\nfunction constructObjectNodeConfig(folderPath: string, id: string, fullName: string, lastModifiedAt: number, size: number): ConnectionNodeConfig {\n    const name = extractNameFromPath(fullName) ?? '';\n    const extension = extractExtensionFromPath(fullName);\n    const lastModifiedAtTimestamp = lastModifiedAt;\n    const mimeType = lookupMimeTypeForExtension(extension);\n    return { id, extension, folderPath, label: fullName, lastModifiedAt: lastModifiedAtTimestamp, mimeType, name, size, typeId: 'object' };\n}\n\n//#endregion ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// Exports.\nexport { Connector };\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","k","I","n","_","A","C","O","P","G","D","f","e","i","r","u","a","l","c","p","y","L","M","S","j","E","d","t","T","o","b","s","m","rustBindingsPromise","addNumbersWithRust","left","right","add_my_numbers","loadRustBindings","yyyy","checksumWithRust","input","checksum_from_rust","URL_PREFIX","Connector","toolConfigs","config","connector","options","fileStoreFolderPaths","fileStoreFolderPathData","folderPath","folderPathNode","signal","response","buildFetchError","OperationalError","xxx","sum","error","normalizeToError","folderNodes","connectionNodeConfigs","folderNode","constructFolderNodeConfig","constructObjectNodeConfig","asAt","startedAt","previewConfig","loadTool","schemaConfig","ORDERED_VALUE_DELIMITER_IDS","duration","chunk","complete","csvParseTool","parseStreamOptions","url","summary","name","childCount","fullName","lastModifiedAt","extractNameFromPath","extension","extractExtensionFromPath","lastModifiedAtTimestamp","mimeType","lookupMimeTypeForExtension"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}