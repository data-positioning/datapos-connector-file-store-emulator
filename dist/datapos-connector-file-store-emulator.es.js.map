{"version":3,"file":"datapos-connector-file-store-emulator.es.js","sources":["../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-connector.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-errors.es.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared-utilities.es.js","../src/rustBridge.ts","../src/index.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { connectorConfigSchema as b } from \"./datapos-shared.es.js\";\nconst n = (e) => {\n  const o = Object.entries(e).filter((t) => typeof t[1] == \"string\");\n  return new Map(o);\n};\nn({ \"en-gb\": \"Application\" }), n({ \"en-gb\": \"Curated Dataset\" }), n({ \"en-gb\": \"Database\" }), n({ \"en-gb\": \"File Store\" });\nasync function i(e, o) {\n  console.log(\"loadToolForConnector\", e, o);\n  const t = `datapos-tool-${o}`, a = e.find((r) => r.id === t);\n  if (!a) throw new Error(`Connector could not load unknown tool '${o}'.`);\n  const l = await import(`https://engine-eu.datapos.app/tools/${o}_v${a.version}/${t}.es.js`);\n  return new l.Tool();\n}\nexport {\n  b as connectorConfigSchema,\n  i as loadToolForConnector\n};\n","class i extends Error {\n  locator;\n  /** Logical source of the error. */\n  constructor(o, t, r) {\n    super(o, r), this.name = new.target.name, this.locator = t;\n  }\n}\nclass a extends i {\n}\nclass g extends a {\n}\nclass p extends a {\n}\nclass c extends a {\n  body;\n  /** Sanitized HTTP response body. */\n  constructor(o, t, r, n) {\n    super(o, t, n), this.name = new.target.name, this.body = E(r ?? void 0);\n  }\n}\nclass y extends i {\n}\nclass m extends a {\n  componentName;\n  /** Vue component name, if available. */\n  info;\n  /** Vue error info string. */\n  constructor(o, t, r, n, s) {\n    super(o, t, s), this.name = new.target.name, this.info = r, this.componentName = n;\n  }\n}\nclass w extends a {\n}\nclass b extends a {\n}\nasync function h(e, o, t) {\n  const r = ` - ${e.statusText}`, n = `${o} Response status '${e.status}${e.statusText ? r : \"\"}' received.`;\n  let s;\n  try {\n    s = await e.text();\n  } catch (d) {\n    s = `<body unavailable: ${l(d).message}>`;\n  }\n  return new c(n, t, s);\n}\nfunction k(e) {\n  return e.map((o) => o.message).join(\" \");\n}\nfunction l(e) {\n  if (e instanceof Error) return e;\n  if (typeof e == \"string\") return new Error(e);\n  if (typeof e == \"number\" || typeof e == \"boolean\" || typeof e == \"bigint\") return new Error(String(e));\n  if (typeof e == \"symbol\") return new Error(e.description ?? \"Unknown error\");\n  if (e != null && typeof e == \"object\")\n    try {\n      return new Error(JSON.stringify(e));\n    } catch {\n      return new Error(\"Unknown error\");\n    }\n  return new Error(\"Unknown error\");\n}\nfunction x(e) {\n  const o = /* @__PURE__ */ new Set(), t = [];\n  let r = e;\n  for (; r != null && !o.has(r); ) {\n    o.add(r);\n    let n;\n    if (r instanceof c)\n      n = { componentName: void 0, body: r.body, info: void 0, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof m)\n      n = {\n        componentName: r.componentName,\n        body: void 0,\n        info: r.info,\n        locator: r.locator,\n        message: r.message,\n        name: r.name,\n        stack: r.stack\n      }, r = r.cause;\n    else if (r instanceof i)\n      n = { componentName: void 0, body: void 0, info: void 0, locator: r.locator, message: r.message, name: r.name, stack: r.stack }, r = r.cause;\n    else if (r instanceof Error) {\n      const s = r;\n      n = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: s.message, name: s.name, stack: s.stack }, r = s.cause;\n    } else\n      n = { componentName: void 0, body: void 0, info: void 0, locator: \"\", message: f(r), name: \"Error\", stack: void 0 }, r = void 0;\n    /(?:\\.{3}|[.!?])$/.test(n.message) || (n.message += \".\"), t.push(n);\n  }\n  return t;\n}\nfunction f(e) {\n  let o;\n  try {\n    o = JSON.stringify(e);\n  } catch {\n    typeof e == \"symbol\" ? o = e.description ?? \"Unknown error\" : typeof e == \"bigint\" ? o = e.toString() : o = \"Unknown error\";\n  }\n  return o === \"\" && (o = \"Unknown error\"), o;\n}\nfunction E(e) {\n  if (!(e == null || e === \"\"))\n    return e.length > 2048 ? `${e.slice(0, 2048)}... [truncated]` : e;\n}\nexport {\n  g as APIError,\n  a as ApplicationError,\n  p as EngineError,\n  c as FetchError,\n  y as OperationalError,\n  m as VueHandledError,\n  b as WindowHandledPromiseRejectionError,\n  w as WindowHandledRuntimeError,\n  h as buildFetchError,\n  k as concatenateSerialisedErrorMessages,\n  l as normalizeToError,\n  x as serialiseError\n};\n","const c = \"en-US\", s = /* @__PURE__ */ new Map();\nfunction f(e) {\n  switch (e) {\n    case \"Edm.Binary\":\n      return \"unknown\";\n    // Binary...\n    case \"Edm.Boolean\":\n      return \"boolean\";\n    case \"Edm.Byte\":\n      return \"wholeNumber\";\n    case \"Edm.DateTime\":\n      return \"moment\";\n    // DateTime...\n    case \"Edm.DateTimeOffset\":\n      return \"moment\";\n    // DateTimeOffset...\n    case \"Edm.Decimal\":\n      return \"decimalNumber\";\n    case \"Edm.Double\":\n      return \"decimalNumber\";\n    case \"Edm.Guid\":\n      return \"string\";\n    case \"Edm.Int16\":\n      return \"wholeNumber\";\n    case \"Edm.Int32\":\n      return \"wholeNumber\";\n    case \"Edm.Int64\":\n      return \"wholeNumber\";\n    case \"Edm.SByte\":\n      return \"wholeNumber\";\n    case \"Edm.Single\":\n      return \"decimalNumber\";\n    case \"Edm.String\":\n      return \"string\";\n    case \"Edm.Time\":\n      return \"momentTime\";\n    // Time...\n    default:\n      return \"unknown\";\n  }\n}\nfunction l(e) {\n  if (e) {\n    const t = e.lastIndexOf(\"/\"), n = e.lastIndexOf(\".\", t === -1 ? e.length : t);\n    return n === -1 ? e : e.slice(0, Math.max(0, n));\n  }\n}\nfunction m(e) {\n  if (e) {\n    const t = e.lastIndexOf(\".\");\n    if (t !== -1) return e.slice(Math.max(0, t + 1));\n  }\n}\nfunction r(e, t = 2, n = t, i = c) {\n  if (e == null) return \"\";\n  const u = `${i}decimal${t}.${n}`;\n  let a = s.get(u);\n  return a || (a = new Intl.NumberFormat(i, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: t,\n    minimumFractionDigits: n,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(u, a)), a.format(e);\n}\nfunction d(e) {\n  return e == null ? \"\" : e < 1e3 ? o(e) : e < 1e6 ? `${r(e / 1e3, 2, 0)}K` : e < 1e9 ? `${r(e / 1e6, 2, 0)}M` : e < 1e12 ? `${r(e / 1e9, 2, 0)}B` : `${r(e / 1e12, 2, 0)}T`;\n}\nfunction x(e) {\n  return e == null ? \"\" : e === 1 ? \"1 byte\" : e < 1024 ? `${o(e)} bytes` : e < 1048576 ? `${r(e / 1024, 2, 0)} KB` : e < 1073741824 ? `${r(e / 1048576, 2, 0)} MB` : e < 1099511627776 ? `${r(e / 1073741824, 2, 0)} GB` : `${r(e / 1099511627776, 2, 0)} TB`;\n}\nfunction p(e) {\n  return e == null ? \"\" : e < 1e3 ? `${o(e)} ms` : e === 1e3 ? `${o(e)} sec` : e < 6e4 ? `${r(e / 1e3, 2, 0)} secs` : e === 6e4 ? \"1 min\" : e < 36e5 ? `${r(e / 6e4, 2, 0)} mins` : e === 36e5 ? \"1 hr\" : e < 864e5 ? `${r(e / 36e5, 2, 0)} hrs` : e === 864e5 ? \"1 day\" : `${r(e / 864e5, 2, 0)} days`;\n}\nfunction o(e, t = c) {\n  if (e == null) return \"\";\n  const n = `${t}decimal0.0`;\n  let i = s.get(n);\n  return i || (i = new Intl.NumberFormat(t, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: 0,\n    minimumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), s.set(n, i)), i.format(e);\n}\nfunction E(e) {\n  switch (e) {\n    case \"csv\":\n      return \"text/csv\";\n    case \"tab\":\n    case \"tsv\":\n      return \"text/tab-separated-values\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\nexport {\n  f as convertODataTypeIdToUsageTypeId,\n  m as extractExtensionFromPath,\n  l as extractNameFromPath,\n  r as formatNumberAsDecimalNumber,\n  p as formatNumberAsDuration,\n  d as formatNumberAsSize,\n  x as formatNumberAsStorageSize,\n  o as formatNumberAsWholeNumber,\n  E as lookupMimeTypeForExtension\n};\n","// Dependencies - Framework\nimport type * as RustModule from '../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js';\n\n// Interfaces/Types\ntype RustBindings = typeof RustModule;\n\n// Module Variables\nlet rustBindingsPromise: Promise<RustBindings> | undefined;\n\n// Utilities\nasync function addNumbersWithRust(left: number, right: number): Promise<number> {\n    const { add_my_numbers } = await loadRustBindings();\n    console.log(1111, left, right);\n    const yyyy = add_my_numbers(Math.trunc(left), Math.trunc(right));\n    console.log(2222, yyyy);\n    return yyyy;\n}\n\n// Utilities\nasync function checksumWithRust(input: string): Promise<number> {\n    const { checksum_from_rust } = await loadRustBindings();\n    return checksum_from_rust(input);\n}\n\n// Helpers\nasync function loadRustBindings(): Promise<RustBindings> {\n    rustBindingsPromise ??= import('../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js');\n    return rustBindingsPromise;\n}\n\n// Exposures\nexport { addNumbersWithRust, checksumWithRust };\n","/*\n * File store emulator connector class.\n */\n\n// NOTE: Consider Cloudflare R2 Download URL: https://plugins-eu.datapositioning.app/connectors/datapos-connector-file-store-emulator-es.js. This would allow us to secure the bucket?\n\n/** Dependencies - Vendor. */\nimport { nanoid } from 'nanoid';\n\n/** Dependencies - Framework. */\nimport type { Tool as CSVParseTool } from '@datapos/datapos-tool-csv-parse';\nimport { loadToolForConnector } from '@datapos/datapos-shared/component/connector';\nimport type { ToolConfig } from '@datapos/datapos-shared';\nimport { buildFetchError, normalizeToError, OperationalError } from '@datapos/datapos-shared/errors';\nimport type {\n    ConnectionConfig,\n    ConnectionNodeConfig,\n    Connector,\n    ConnectorConfig,\n    FindResult,\n    FindSettings,\n    GetReadableStreamResult,\n    GetReadableStreamSettings,\n    ListResult,\n    ListSettings,\n    PreviewResult,\n    PreviewSettings,\n    RetrieveRecordsSettings,\n    RetrieveRecordsSummary\n} from '@datapos/datapos-shared/component/connector';\nimport { extractExtensionFromPath, extractNameFromPath, lookupMimeTypeForExtension } from '@datapos/datapos-shared/utilities';\n\n/** Dependencies - Data. */\nimport config from '~/config.json';\nimport fileStoreIndex from '@/fileStoreIndex.json';\nimport { version } from '~/package.json';\nimport { addNumbersWithRust, checksumWithRust } from '@/rustBridge';\n\n/** Interfaces/Types - File store index. */\ntype FileStoreIndexItem =\n    | ({ typeId: 'folder'; childCount: number } & { name: string })\n    | ({ typeId: 'object'; id: string; lastModifiedAt: number; size: number } & { name: string });\ntype FileStoreIndex = Record<string, FileStoreIndexItem[]>;\n\n/** Constants */\nconst CALLBACK_PREVIEW_ABORTED = 'Connector failed to abort preview object operation.';\nconst CALLBACK_RETRIEVE_ABORTED = 'Connector failed to abort retrieve all records operation.';\nconst DEFAULT_PREVIEW_CHUNK_SIZE = 4096;\nconst DEFAULT_RETRIEVE_CHUNK_SIZE = 1000;\nconst URL_PREFIX = 'https://sample-data-eu.datapos.app';\n\n/** Classes - File store emulator connector. */\nexport default class FileStoreEmulatorConnector implements Connector {\n    abortController: AbortController | undefined;\n    readonly config: ConnectorConfig;\n    readonly connectionConfig: ConnectionConfig;\n    readonly toolConfigs;\n\n    constructor(connectionConfig: ConnectionConfig, toolConfigs: ToolConfig[]) {\n        this.abortController = undefined;\n        this.config = config as ConnectorConfig;\n        this.config.version = version;\n        this.connectionConfig = connectionConfig;\n        this.toolConfigs = toolConfigs;\n    }\n\n    /** Abort operation. */\n    abortOperation(connector: Connector): void {\n        if (!connector.abortController) return;\n        connector.abortController.abort();\n        connector.abortController = undefined;\n    }\n\n    /** Find object. */\n    findObject(connector: Connector, settings: FindSettings): Promise<FindResult> {\n        // Loop through the file store index checking for an object entry with an identifier equal to the object name.\n        for (const folderPath in fileStoreIndex) {\n            if (Object.prototype.hasOwnProperty.call(fileStoreIndex, folderPath)) {\n                // eslint-disable-next-line security/detect-object-injection\n                const indexItems = (fileStoreIndex as FileStoreIndex)[folderPath];\n                const indexItem = indexItems?.find((indexItem) => indexItem.typeId === 'object' && indexItem.id === settings.objectName);\n                if (indexItem) return Promise.resolve({ folderPath }); // Found, return folder path.\n            }\n        }\n        return Promise.resolve({}); // Not found, return undefined folder path.\n    }\n\n    // Operations - Get readable stream.\n    async getReadableStream(connector: Connector, settings: GetReadableStreamSettings): Promise<GetReadableStreamResult> {\n        try {\n            console.log('getReader', 'settings', settings);\n            const url = `${URL_PREFIX}/fileStore${settings.path}`;\n            const response = await fetch(url); // 'https://sample-data-eu.datapos.app/WDI_Data.csv' or 'https://sample-data-eu.datapos.app/fileStore/ENGAGEMENT_START_EVENTS_202405121858.csv'\n            console.log('getReader', 'response', response);\n            if (!response.body) throw new Error('ReadableStream not supported by this browser.');\n\n            const xxx = await addNumbersWithRust(12, 56);\n            const sum = await checksumWithRust(connector.config.version);\n            console.log('sum', sum, xxx);\n\n            return await Promise.resolve({ readable: response.body });\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - List nodes.\n    listNodes(connector: Connector, settings: ListSettings): Promise<ListResult> {\n        const indexItems = (fileStoreIndex as FileStoreIndex)[settings.folderPath] ?? [];\n        const connectionNodeConfigs: ConnectionNodeConfig[] = [];\n        for (const indexItem of indexItems) {\n            if (indexItem.typeId === 'folder') {\n                connectionNodeConfigs.push(this.constructFolderNodeConfig(settings.folderPath, indexItem.name, indexItem.childCount));\n            } else {\n                connectionNodeConfigs.push(this.constructObjectNodeConfig(settings.folderPath, indexItem.id, indexItem.name, indexItem.lastModifiedAt, indexItem.size));\n            }\n        }\n        return Promise.resolve({ cursor: undefined, isMore: false, connectionNodeConfigs, totalCount: connectionNodeConfigs.length });\n    }\n\n    // Operations - Preview object.\n    async previewObject(connector: Connector, settings: PreviewSettings): Promise<PreviewResult> {\n        try {\n            // Create an abort controller. Get the signal for the abort controller and add an abort listener.\n            connector.abortController = new AbortController();\n            const signal = connector.abortController.signal;\n            signal.addEventListener('abort', () => {\n                throw new OperationalError(CALLBACK_PREVIEW_ABORTED, 'datapos-connector-file-store-emulator|Connector|preview.abort');\n            });\n\n            // Fetch chunk from start of file.\n            const url = `${URL_PREFIX}/fileStore${settings.path}`;\n            const chunkSize = settings.chunkSize ?? DEFAULT_PREVIEW_CHUNK_SIZE;\n            const headers: HeadersInit = { Range: `bytes=0-${chunkSize}` };\n            const response = await fetch(encodeURI(url), { headers, signal });\n            if (response.ok) {\n                connector.abortController = undefined;\n                return { data: new Uint8Array(await response.arrayBuffer()), typeId: 'uint8Array' };\n            } else {\n                throw await buildFetchError(response, `Failed to fetch '${settings.path}' file.`, 'datapos-connector-file-store-emulator|Connector|preview');\n            }\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - Retrieve records.\n    async retrieveRecords(\n        connector: Connector,\n        settings: RetrieveRecordsSettings,\n        chunk: (records: string[][]) => void,\n        complete: (result: RetrieveRecordsSummary) => void\n    ): Promise<void> {\n        const csvParseTool = await loadToolForConnector<CSVParseTool>(connector.toolConfigs, 'csv-parse');\n        console.log(1234, csvParseTool);\n        return new Promise((resolve, reject) => {\n            try {\n                // Create an abort controller and get the signal. Add an abort listener to the signal.\n                connector.abortController = new AbortController();\n                const signal = connector.abortController.signal;\n                signal.addEventListener(\n                    'abort',\n                    () => {\n                        connector.abortController = undefined;\n                        reject(new OperationalError(CALLBACK_RETRIEVE_ABORTED, 'datapos-connector-file-store-emulator|Connector|retrieve.abort'));\n                    },\n                    { once: true }\n                );\n\n                // Parser - Declare variables.\n                let pendingRows: string[][] = []; // Array to store rows of parsed field values and associated information.\n\n                // Parser - Create a parser object for CSV parsing.\n                const parser = csvParseTool.buildParser({\n                    delimiter: settings.valueDelimiterId,\n                    info: true,\n                    relax_column_count: true,\n                    relax_quotes: true\n                });\n\n                // Parser - Event listener for the 'readable' (data available) event.\n                parser.on('readable', () => {\n                    try {\n                        let data: string[] | null;\n                        while ((data = parser.read() as string[] | null) !== null) {\n                            signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                            pendingRows.push(data); // Append the row of parsed values and associated information to the pending rows array.\n                            if (pendingRows.length < DEFAULT_RETRIEVE_CHUNK_SIZE) continue; // Continue with next iteration if the pending rows array is not yet full.\n                            chunk(pendingRows); // Pass the pending rows to the engine using the 'chunk' callback.\n                            pendingRows = []; // Clear the pending rows array in preparation for the next batch of data.\n                        }\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Parser - Event listener for the 'error' event.\n                parser.on('error', (error) => {\n                    connector.abortController = undefined;\n                    reject(normalizeToError(error));\n                });\n\n                // Parser - Event listener for the 'end' (end of data) event.\n                parser.on('end', () => {\n                    try {\n                        signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                        connector.abortController = undefined; // Clear the abort controller.\n                        if (pendingRows.length > 0) {\n                            chunk(pendingRows);\n                            pendingRows = [];\n                        }\n                        complete({\n                            byteCount: parser.info.bytes,\n                            commentLineCount: parser.info.comment_lines,\n                            emptyLineCount: parser.info.empty_lines,\n                            invalidFieldLengthCount: parser.info.invalid_field_length,\n                            lineCount: parser.info.lines,\n                            recordCount: parser.info.records\n                        });\n                        resolve();\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Fetch, decode and forward the contents of the file to the parser.\n                const url = `${URL_PREFIX}/fileStore${settings.path}`;\n                fetch(encodeURI(url), { signal })\n                    .then(async (response) => {\n                        try {\n                            if (response.ok && response.body) {\n                                const stream = response.body.pipeThrough(new TextDecoderStream(settings.encodingId));\n                                const decodedStreamReader = stream.getReader();\n                                let result = await decodedStreamReader.read();\n                                while (!result.done) {\n                                    signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                                    // Write the decoded data to the parser and terminate if there is an error.\n                                    parser.write(result.value, (error) => {\n                                        if (error) {\n                                            connector.abortController = undefined;\n                                            reject(normalizeToError(error));\n                                        }\n                                    });\n                                    result = await decodedStreamReader.read();\n                                }\n                                parser.end(); // Signal no more data will be written.\n                            } else {\n                                const error = await buildFetchError(\n                                    response,\n                                    `Failed to fetch '${settings.path}' file.`,\n                                    'datapos-connector-file-store-emulator|Connector|retrieve'\n                                );\n                                connector.abortController = undefined;\n                                reject(error);\n                            }\n                        } catch (error) {\n                            connector.abortController = undefined;\n                            reject(normalizeToError(error));\n                        }\n                    })\n                    .catch((error: unknown) => {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    });\n            } catch (error) {\n                connector.abortController = undefined;\n                reject(normalizeToError(error));\n            }\n        });\n    }\n\n    /** Utilities - Construct folder node configuration. */\n    private constructFolderNodeConfig(folderPath: string, name: string, childCount: number): ConnectionNodeConfig {\n        return { id: nanoid(), childCount, extension: undefined, folderPath, label: name, name, typeId: 'folder' };\n    }\n\n    /** Utilities - Construct object (file) node configuration. */\n    private constructObjectNodeConfig(folderPath: string, id: string, fullName: string, lastModifiedAt: number, size: number): ConnectionNodeConfig {\n        const name = extractNameFromPath(fullName) ?? '';\n        const extension = extractExtensionFromPath(fullName);\n        const lastModifiedAtTimestamp = lastModifiedAt;\n        const mimeType = lookupMimeTypeForExtension(extension);\n        return { id, extension, folderPath, label: fullName, lastModifiedAt: lastModifiedAtTimestamp, mimeType, name, size, typeId: 'object' };\n    }\n\n    // // Helpers - Load tool for connector.\n    // private async loadToolForConnector<T>(connector: Connector, toolId: string): Promise<T> {\n    //     const toolName = `datapos-tool-${toolId}`;\n    //     const toolModuleConfig = connector.toolConfigs.find((config) => config.id === toolName);\n    //     if (!toolModuleConfig) throw new Error(`Unknown tool '${toolId}'.`);\n\n    //     const url = `https://engine-eu.datapos.app/tools/${toolId}_v${toolModuleConfig.version}/${toolName}.es.js`;\n    //     const toolModule = (await import(/* @vite-ignore */ url)) as { Tool: new () => T };\n    //     const toolInstance = new toolModule.Tool();\n    //     return toolInstance;\n    // }\n}\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","n","e","o","t","i","a","r","l","c","E","y","h","s","d","m","rustBindingsPromise","addNumbersWithRust","left","right","add_my_numbers","loadRustBindings","yyyy","checksumWithRust","input","checksum_from_rust","CALLBACK_PREVIEW_ABORTED","CALLBACK_RETRIEVE_ABORTED","DEFAULT_PREVIEW_CHUNK_SIZE","DEFAULT_RETRIEVE_CHUNK_SIZE","URL_PREFIX","FileStoreEmulatorConnector","connectionConfig","toolConfigs","config","version","connector","settings","folderPath","fileStoreIndex","indexItem","url","response","xxx","sum","error","indexItems","connectionNodeConfigs","signal","OperationalError","headers","buildFetchError","chunk","complete","csvParseTool","loadToolForConnector","resolve","reject","pendingRows","parser","data","normalizeToError","decodedStreamReader","result","name","childCount","fullName","lastModifiedAt","extractNameFromPath","extension","extractExtensionFromPath","lastModifiedAtTimestamp","mimeType","lookupMimeTypeForExtension"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}