{"version":3,"file":"datapos-connector-file-store-emulator.es.js","sources":["../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../node_modules/@datapos/datapos-shared/dist/datapos-shared.es.js","../src/rustBridge.ts","../src/index.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","let j;\n// @__NO_SIDE_EFFECTS__\nfunction H(e) {\n  return {\n    lang: e?.lang ?? j?.lang,\n    message: e?.message,\n    abortEarly: e?.abortEarly ?? j?.abortEarly,\n    abortPipeEarly: e?.abortPipeEarly ?? j?.abortPipeEarly\n  };\n}\nlet K;\n// @__NO_SIDE_EFFECTS__\nfunction W(e) {\n  return K?.get(e);\n}\nlet X;\n// @__NO_SIDE_EFFECTS__\nfunction J(e) {\n  return X?.get(e);\n}\nlet q;\n// @__NO_SIDE_EFFECTS__\nfunction Q(e, r) {\n  return q?.get(e)?.get(r);\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e) {\n  const r = typeof e;\n  return r === \"string\" ? `\"${e}\"` : r === \"number\" || r === \"bigint\" || r === \"boolean\" ? `${e}` : r === \"object\" || r === \"function\" ? (e && Object.getPrototypeOf(e)?.constructor?.name) ?? \"null\" : r;\n}\nfunction g(e, r, t, n, s) {\n  const o = s && \"input\" in s ? s.input : t.value, i = s?.expected ?? e.expects ?? null, u = s?.received ?? /* @__PURE__ */ U(o), a = {\n    kind: e.kind,\n    type: e.type,\n    input: o,\n    expected: i,\n    received: u,\n    message: `Invalid ${r}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${u}`,\n    requirement: e.requirement,\n    path: s?.path,\n    issues: s?.issues,\n    lang: n.lang,\n    abortEarly: n.abortEarly,\n    abortPipeEarly: n.abortPipeEarly\n  }, p = e.kind === \"schema\", d = s?.message ?? e.message ?? /* @__PURE__ */ Q(e.reference, a.lang) ?? (p ? /* @__PURE__ */ J(a.lang) : null) ?? n.message ?? /* @__PURE__ */ W(a.lang);\n  d !== void 0 && (a.message = typeof d == \"function\" ? d(a) : d), p && (t.typed = !1), t.issues ? t.issues.push(a) : t.issues = [a];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(r) {\n      return e[\"~run\"]({ value: r }, /* @__PURE__ */ H());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction Y(e, r) {\n  return Object.hasOwn(e, r) && r !== \"__proto__\" && r !== \"prototype\" && r !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction Z(e, r) {\n  const t = [...new Set(e)];\n  return t.length > 1 ? `(${t.join(` ${r} `)})` : t[0] ?? \"never\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction ee(e, r, t) {\n  return typeof e.fallback == \"function\" ? e.fallback(r, t) : e.fallback;\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e, r, t) {\n  return typeof e.default == \"function\" ? e.default(r, t) : e.default;\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: x,\n    expects: \"Array\",\n    async: !1,\n    item: e,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      const s = t.value;\n      if (Array.isArray(s)) {\n        t.typed = !0, t.value = [];\n        for (let o = 0; o < s.length; o++) {\n          const i = s[o], u = this.item[\"~run\"]({ value: i }, n);\n          if (u.issues) {\n            const a = {\n              type: \"array\",\n              origin: \"value\",\n              input: s,\n              key: o,\n              value: i\n            };\n            for (const p of u.issues)\n              p.path ? p.path.unshift(a) : p.path = [a], t.issues?.push(p);\n            if (t.issues || (t.issues = u.issues), n.abortEarly) {\n              t.typed = !1;\n              break;\n            }\n          }\n          u.typed || (t.typed = !1), t.value.push(u.value);\n        }\n      } else g(this, \"type\", t, n);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction B(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: B,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return typeof r.value == \"boolean\" ? r.typed = !0 : g(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: D,\n    expects: /* @__PURE__ */ U(e),\n    async: !1,\n    literal: e,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      return t.value === this.literal ? t.typed = !0 : g(this, \"type\", t, n), t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction y(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: y,\n    expects: `(${e.expects} | null)`,\n    async: !1,\n    wrapped: e,\n    default: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      return t.value === null && (this.default !== void 0 && (t.value = /* @__PURE__ */ A(this, t, n)), t.value === null) ? (t.typed = !0, t) : this.wrapped[\"~run\"](t, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: k,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return typeof r.value == \"number\" && !isNaN(r.value) ? r.typed = !0 : g(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction b(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: b,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      const s = t.value;\n      if (s && typeof s == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in this.entries) {\n          const i = this.entries[o];\n          if (o in s || (i.type === \"exact_optional\" || i.type === \"optional\" || i.type === \"nullish\") && i.default !== void 0) {\n            const u = o in s ? s[o] : /* @__PURE__ */ A(i), a = i[\"~run\"]({ value: u }, n);\n            if (a.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: o,\n                value: u\n              };\n              for (const d of a.issues)\n                d.path ? d.path.unshift(p) : d.path = [p], t.issues?.push(d);\n              if (t.issues || (t.issues = a.issues), n.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            a.typed || (t.typed = !1), t.value[o] = a.value;\n          } else if (i.fallback !== void 0) t.value[o] = /* @__PURE__ */ ee(i);\n          else if (i.type !== \"exact_optional\" && i.type !== \"optional\" && i.type !== \"nullish\" && (g(this, \"key\", t, n, {\n            input: void 0,\n            expected: `\"${o}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input: s,\n              key: o,\n              value: s[o]\n            }]\n          }), n.abortEarly))\n            break;\n        }\n      } else g(this, \"type\", t, n);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction f(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: f,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      return t.value === void 0 && (this.default !== void 0 && (t.value = /* @__PURE__ */ A(this, t, n)), t.value === void 0) ? (t.typed = !0, t) : this.wrapped[\"~run\"](t, n);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e, r, t) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: R,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: r,\n    message: t,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, s) {\n      const o = n.value;\n      if (o && typeof o == \"object\") {\n        n.typed = !0, n.value = {};\n        for (const i in o) if (/* @__PURE__ */ Y(o, i)) {\n          const u = o[i], a = this.key[\"~run\"]({ value: i }, s);\n          if (a.issues) {\n            const d = {\n              type: \"object\",\n              origin: \"key\",\n              input: o,\n              key: i,\n              value: u\n            };\n            for (const S of a.issues)\n              S.path = [d], n.issues?.push(S);\n            if (n.issues || (n.issues = a.issues), s.abortEarly) {\n              n.typed = !1;\n              break;\n            }\n          }\n          const p = this.value[\"~run\"]({ value: u }, s);\n          if (p.issues) {\n            const d = {\n              type: \"object\",\n              origin: \"value\",\n              input: o,\n              key: i,\n              value: u\n            };\n            for (const S of p.issues)\n              S.path ? S.path.unshift(d) : S.path = [d], n.issues?.push(S);\n            if (n.issues || (n.issues = p.issues), s.abortEarly) {\n              n.typed = !1;\n              break;\n            }\n          }\n          (!a.typed || !p.typed) && (n.typed = !1), a.typed && (n.value[a.value] = p.value);\n        }\n      } else g(this, \"type\", n, s);\n      return n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction l(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: l,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return typeof r.value == \"string\" ? r.typed = !0 : g(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  let r;\n  if (e) for (const t of e) r ? r.push(...t.issues) : r = t.issues;\n  return r;\n}\n// @__NO_SIDE_EFFECTS__\nfunction G(e, r) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: G,\n    expects: /* @__PURE__ */ Z(e.map((t) => t.expects), \"|\"),\n    async: !1,\n    options: e,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, n) {\n      let s, o, i;\n      for (const u of this.options) {\n        const a = u[\"~run\"]({ value: t.value }, n);\n        if (a.typed) if (a.issues) o ? o.push(a) : o = [a];\n        else {\n          s = a;\n          break;\n        }\n        else i ? i.push(a) : i = [a];\n      }\n      if (s) return s;\n      if (o) {\n        if (o.length === 1) return o[0];\n        g(this, \"type\", t, n, { issues: /* @__PURE__ */ _(o) }), t.typed = !0;\n      } else {\n        if (i?.length === 1) return i[0];\n        g(this, \"type\", t, n, { issues: /* @__PURE__ */ _(i) });\n      }\n      return t;\n    }\n  };\n}\nconst v = (e) => /* @__PURE__ */ G(e.map((r) => /* @__PURE__ */ D(r))), te = /* @__PURE__ */ b({\n  \"en-au\": /* @__PURE__ */ l(),\n  \"en-gb\": /* @__PURE__ */ l(),\n  \"en-us\": /* @__PURE__ */ l(),\n  \"es-es\": /* @__PURE__ */ l()\n}), C = /* @__PURE__ */ b({\n  \"en-au\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"en-gb\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"en-us\": /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  \"es-es\": /* @__PURE__ */ f(/* @__PURE__ */ l())\n}), re = v([\"amber\", \"green\", \"red\", \"other\"]), ne = v([\n  \"alpha\",\n  \"beta\",\n  \"generalAvailability\",\n  \"notApplicable\",\n  \"preAlpha\",\n  \"proposed\",\n  \"releaseCandidate\",\n  \"unavailable\",\n  \"underReview\"\n]), se = v([\n  \"app\",\n  \"connector\",\n  \"connectorConnection\",\n  \"context\",\n  \"contextModelGroup\",\n  \"contextModel\",\n  \"contextModelDimensionGroup\",\n  \"contextModelDimension\",\n  \"contextModelDimensionHierarchy\",\n  \"contextModelEntityGroup\",\n  \"contextModelEntity\",\n  \"contextModelEntityDataItem\",\n  \"contextModelEntityEvent\",\n  \"contextModelEntityPrimaryMeasure\",\n  \"contextModelSecondaryMeasureGroup\",\n  \"contextModelSecondaryMeasure\",\n  \"dataView\",\n  \"dimension\",\n  \"engine\",\n  \"eventQuery\",\n  \"presenter\",\n  \"presenterPresentation\",\n  \"tool\"\n]);\nv([\"app\", \"engine\", \"connector\", \"context\", \"presenter\", \"tool\"]);\nconst oe = /* @__PURE__ */ b({\n  id: /* @__PURE__ */ l(),\n  color: re,\n  label: /* @__PURE__ */ l()\n}), T = {\n  id: /* @__PURE__ */ l(),\n  label: C,\n  description: C,\n  firstCreatedAt: /* @__PURE__ */ f(/* @__PURE__ */ k()),\n  icon: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  iconDark: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  lastUpdatedAt: /* @__PURE__ */ y(/* @__PURE__ */ k()),\n  status: /* @__PURE__ */ y(oe),\n  statusId: ne\n}, Se = /* @__PURE__ */ b({\n  ...T,\n  typeId: se\n}), $ = {\n  ...T,\n  version: /* @__PURE__ */ l()\n}, P = /* @__PURE__ */ b({\n  id: /* @__PURE__ */ l(),\n  label: C,\n  description: C,\n  icon: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  iconDark: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  order: /* @__PURE__ */ k(),\n  path: /* @__PURE__ */ l()\n}), E = (e) => {\n  const r = Object.entries(e).filter((t) => typeof t[1] == \"string\");\n  return new Map(r);\n}, ie = (e, r, t = I) => {\n  const n = e.get(r);\n  if (n !== void 0) return n;\n  if (t !== r)\n    return e.get(t);\n}, ae = [\n  { id: \"alpha\", color: \"red\", labels: E({ \"en-gb\": \"alpha\" }) },\n  { id: \"beta\", color: \"amber\", labels: E({ \"en-gb\": \"beta\" }) },\n  { id: \"generalAvailability\", color: \"green\", labels: E({ \"en-gb\": \"\" }) },\n  { id: \"notApplicable\", color: \"green\", labels: E({ \"en-gb\": \"not-applicable\" }) },\n  { id: \"preAlpha\", color: \"red\", labels: E({ \"en-gb\": \"pre-alpha\" }) },\n  { id: \"proposed\", color: \"other\", labels: E({ \"en-gb\": \"proposed\" }) },\n  { id: \"releaseCandidate\", color: \"green\", labels: E({ \"en-gb\": \"release-candidate\" }) },\n  { id: \"unavailable\", color: \"other\", labels: E({ \"en-gb\": \"unavailable\" }) },\n  { id: \"underReview\", color: \"other\", labels: E({ \"en-gb\": \"under-review\" }) }\n], ke = (e, r = I) => {\n  const t = ae.find((n) => n.id === e);\n  if (t) {\n    const n = ie(t.labels, r);\n    return { id: t.id, color: t.color, label: n ?? t.id };\n  }\n  return { id: e, color: \"other\", label: e };\n}, le = v([\"apiKey\", \"disabled\", \"oAuth2\", \"none\"]), ce = v([\"application\", \"curatedDataset\", \"database\", \"fileStore\"]), ue = v([\n  \"abortOperation\",\n  \"authenticateConnection\",\n  \"createObject\",\n  \"describeConnection\",\n  \"dropObject\",\n  \"findObject\",\n  \"getReadableStream\",\n  \"getRecord\",\n  \"listNodes\",\n  \"previewObject\",\n  \"removeRecords\",\n  \"retrieveChunks\",\n  \"retrieveRecords\",\n  \"upsertRecords\"\n]), pe = v([\"bidirectional\", \"destination\", \"source\", \"unknown\"]), de = /* @__PURE__ */ b({\n  authMethodId: le,\n  activeConnectionCount: /* @__PURE__ */ f(/* @__PURE__ */ k()),\n  canDescribe: /* @__PURE__ */ f(/* @__PURE__ */ B()),\n  id: /* @__PURE__ */ f(/* @__PURE__ */ l()),\n  label: /* @__PURE__ */ f(te),\n  maxConnectionCount: /* @__PURE__ */ f(/* @__PURE__ */ k()),\n  params: /* @__PURE__ */ f(/* @__PURE__ */ x(/* @__PURE__ */ R(/* @__PURE__ */ l(), /* @__PURE__ */ l())))\n}), De = /* @__PURE__ */ b({\n  ...$,\n  typeId: /* @__PURE__ */ D(\"connector\"),\n  category: /* @__PURE__ */ y(/* @__PURE__ */ b({ id: /* @__PURE__ */ l(), label: /* @__PURE__ */ l() })),\n  categoryId: ce,\n  implementations: /* @__PURE__ */ R(/* @__PURE__ */ l(), de),\n  operations: /* @__PURE__ */ x(ue),\n  usageId: pe,\n  vendorAccountURL: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  vendorDocumentationURL: /* @__PURE__ */ y(/* @__PURE__ */ l()),\n  vendorHomeURL: /* @__PURE__ */ y(/* @__PURE__ */ l())\n}), we = [\"createObject\", \"dropObject\", \"removeRecords\", \"upsertRecords\"], Ie = [\"findObject\", \"getRecord\", \"listNodes\", \"previewObject\", \"retrieveRecords\"], O = (e) => {\n  const r = Object.entries(e).filter((t) => typeof t[1] == \"string\");\n  return new Map(r);\n};\nO({ \"en-gb\": \"Application\" }), O({ \"en-gb\": \"Curated Dataset\" }), O({ \"en-gb\": \"Database\" }), O({ \"en-gb\": \"File Store\" });\nconst fe = v([\"list\"]), me = /* @__PURE__ */ b({\n  ...T,\n  typeId: /* @__PURE__ */ D(\"contextModelGroup\"),\n  modelRefs: /* @__PURE__ */ x(P),\n  order: /* @__PURE__ */ k()\n}), Oe = /* @__PURE__ */ b({\n  ...$,\n  typeId: /* @__PURE__ */ D(\"context\"),\n  models: /* @__PURE__ */ x(me),\n  operations: /* @__PURE__ */ x(fe)\n});\nclass F extends Error {\n  locator;\n  constructor(r, t, n) {\n    super(r, n), this.name = \"DataPosError\", this.locator = t;\n  }\n}\nclass w extends F {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"ApplicationError\";\n  }\n}\nclass Ce extends w {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"APIError\";\n  }\n}\nclass Me extends w {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"EngineError\";\n  }\n}\nclass z extends w {\n  body;\n  constructor(r, t, n, s) {\n    super(r, t, s), this.name = \"FetchError\", this.body = n;\n  }\n}\nclass be extends w {\n  componentName;\n  info;\n  constructor(r, t, n, s, o) {\n    super(r, t, o), this.name = \"VueHandledError\", this.info = n, this.componentName = s;\n  }\n}\nclass Ne extends w {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"WindowHandledRuntimeError\";\n  }\n}\nclass je extends w {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"WindowHandledPromiseRejectionError\";\n  }\n}\nclass Ae extends F {\n  constructor(r, t, n) {\n    super(r, t, n), this.name = \"OperationalError\";\n  }\n}\nasync function Re(e, r, t) {\n  const n = ` - ${e.statusText}`, s = `${r} Response status '${e.status}${e.statusText ? n : \"\"}' received.`, o = await e.text();\n  return new z(s, t, o);\n}\nfunction Te(e) {\n  return e.map((r) => r.message).join(\" \");\n}\nfunction $e(e) {\n  if (e instanceof Error) return e;\n  if (typeof e == \"string\") return new Error(e);\n  if (typeof e == \"number\" || typeof e == \"boolean\" || typeof e == \"bigint\") return new Error(String(e));\n  if (typeof e == \"symbol\") return new Error(e.description ?? \"Unknown error\");\n  if (e && typeof e == \"object\")\n    try {\n      return new Error(JSON.stringify(e));\n    } catch {\n      return new Error(\"Unknown error\");\n    }\n  return new Error(\"Unknown error\");\n}\nfunction Fe(e) {\n  const r = /* @__PURE__ */ new Set(), t = [];\n  let n = e;\n  for (; n && !r.has(n); ) {\n    r.add(n);\n    let s;\n    if (n instanceof z)\n      s = { body: n.body, locator: n.locator, message: n.message, name: n.name, stack: n.stack }, n = n.cause;\n    else if (n instanceof be)\n      s = { componentName: n.componentName, info: n.info, locator: n.locator, message: n.message, name: n.name, stack: n.stack }, n = n.cause;\n    else if (n instanceof F)\n      s = { locator: n.locator, message: n.message, name: n.name, stack: n.stack }, n = n.cause;\n    else if (n instanceof Error) {\n      const o = n;\n      s = { locator: \"\", message: o.message, name: o.name, stack: o.stack }, n = o.cause;\n    } else\n      s = { locator: \"\", message: String(n), name: \"Error\" }, n = void 0;\n    /(?:\\.{3}|[.!?])$/.test(s.message) || (s.message += \".\"), t.push(s);\n  }\n  return t;\n}\nconst ye = v([\"list\", \"render\", \"setColorMode\"]), Le = /* @__PURE__ */ b({\n  ...$,\n  typeId: /* @__PURE__ */ D(\"presenter\"),\n  presentations: /* @__PURE__ */ x(P),\n  operations: /* @__PURE__ */ x(ye)\n});\nfunction _e() {\n  return { render: ge };\n}\nfunction ge(e, r, t) {\n  t.textContent = \"Cytoscape.js diagram goes here...\";\n}\nfunction Ue() {\n  return { render: he };\n}\nfunction he(e, r) {\n  console.log(1111, e), console.log(2222, r), console.log(3333, r.childNodes), console.log(4444, r.children);\n}\nconst V = \"en-US\", M = /* @__PURE__ */ new Map();\nfunction Be(e) {\n  switch (e) {\n    case \"Edm.Binary\":\n      return \"unknown\";\n    // Binary...\n    case \"Edm.Boolean\":\n      return \"boolean\";\n    case \"Edm.Byte\":\n      return \"wholeNumber\";\n    case \"Edm.DateTime\":\n      return \"moment\";\n    // DateTime...\n    case \"Edm.DateTimeOffset\":\n      return \"moment\";\n    // DateTimeOffset...\n    case \"Edm.Decimal\":\n      return \"decimalNumber\";\n    case \"Edm.Double\":\n      return \"decimalNumber\";\n    case \"Edm.Guid\":\n      return \"string\";\n    case \"Edm.Int16\":\n      return \"wholeNumber\";\n    case \"Edm.Int32\":\n      return \"wholeNumber\";\n    case \"Edm.Int64\":\n      return \"wholeNumber\";\n    case \"Edm.SByte\":\n      return \"wholeNumber\";\n    case \"Edm.Single\":\n      return \"decimalNumber\";\n    case \"Edm.String\":\n      return \"string\";\n    case \"Edm.Time\":\n      return \"momentTime\";\n    // Time...\n    default:\n      return \"unknown\";\n  }\n}\nfunction Ge(e) {\n  if (e) {\n    const r = e.lastIndexOf(\"/\"), t = e.lastIndexOf(\".\", r === -1 ? e.length : r);\n    return t === -1 ? e : e.slice(0, Math.max(0, t));\n  }\n}\nfunction Pe(e) {\n  if (e) {\n    const r = e.lastIndexOf(\".\");\n    if (r !== -1) return e.slice(Math.max(0, r + 1));\n  }\n}\nfunction m(e, r = 2, t = r, n = V) {\n  if (e == null) return \"\";\n  const s = `${n}decimal${r}.${t}`;\n  let o = M.get(s);\n  return o || (o = new Intl.NumberFormat(n, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: r,\n    minimumFractionDigits: t,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), M.set(s, o)), o.format(e);\n}\nfunction ze(e) {\n  return e == null ? \"\" : e < 1e3 ? N(e) : e < 1e6 ? `${m(e / 1e3, 2, 0)}K` : e < 1e9 ? `${m(e / 1e6, 2, 0)}M` : e < 1e12 ? `${m(e / 1e9, 2, 0)}B` : `${m(e / 1e12, 2, 0)}T`;\n}\nfunction Ve(e) {\n  return e == null ? \"\" : e === 1 ? \"1 byte\" : e < 1024 ? `${N(e)} bytes` : e < 1048576 ? `${m(e / 1024, 2, 0)} KB` : e < 1073741824 ? `${m(e / 1048576, 2, 0)} MB` : e < 1099511627776 ? `${m(e / 1073741824, 2, 0)} GB` : `${m(e / 1099511627776, 2, 0)} TB`;\n}\nfunction He(e) {\n  return e == null ? \"\" : e < 1e3 ? `${N(e)} ms` : e === 1e3 ? `${N(e)} sec` : e < 6e4 ? `${m(e / 1e3, 2, 0)} secs` : e === 6e4 ? \"1 min\" : e < 36e5 ? `${m(e / 6e4, 2, 0)} mins` : e === 36e5 ? \"1 hr\" : e < 864e5 ? `${m(e / 36e5, 2, 0)} hrs` : e === 864e5 ? \"1 day\" : `${m(e / 864e5, 2, 0)} days`;\n}\nfunction N(e, r = V) {\n  if (e == null) return \"\";\n  const t = `${r}decimal0.0`;\n  let n = M.get(t);\n  return n || (n = new Intl.NumberFormat(r, {\n    localeMatcher: \"best fit\",\n    maximumFractionDigits: 0,\n    minimumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    style: \"decimal\",\n    useGrouping: !0\n  }), M.set(t, n)), n.format(e);\n}\nfunction Ke(e) {\n  switch (e) {\n    case \"csv\":\n      return \"text/csv\";\n    case \"tab\":\n    case \"tsv\":\n      return \"text/tab-separated-values\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\nconst c = (e) => new Map(Object.entries(e)), L = (e, r, t = I) => {\n  const n = e.get(r);\n  if (n !== void 0) return n;\n  if (t !== r)\n    return e.get(t);\n}, ve = [\n  { id: \"dtv\", labels: c({ \"en-gb\": \"Delimited Text\" }) },\n  { id: \"e/e\", labels: c({ \"en-gb\": \"Entity/Event\" }) },\n  { id: \"jsonArray\", labels: c({ \"en-gb\": \"JSON Array\" }) },\n  { id: \"spss\", labels: c({ \"en-gb\": \"SPSS\" }) },\n  { id: \"xls\", labels: c({ \"en-gb\": \"XLS\" }) },\n  { id: \"xlsx\", labels: c({ \"en-gb\": \"XLSX\" }) },\n  { id: \"xml\", labels: c({ \"en-gb\": \"XML\" }) }\n], We = (e = I) => {\n  const r = [];\n  for (const t of ve) {\n    const n = L(t.labels, e);\n    r.push({ id: t.id, label: n ?? t.id });\n  }\n  return r;\n}, Ee = [\n  { id: `\n`, labels: c({ \"en-gb\": \"Newline\" }) },\n  { id: \"\\r\", labels: c({ \"en-gb\": \"Carriage Return\" }) },\n  { id: `\\r\n`, labels: c({ \"en-gb\": \"Carriage Return/Newline\" }) }\n], Xe = (e = I) => {\n  const r = [];\n  for (const t of Ee) {\n    const n = L(t.labels, e);\n    r.push({ id: t.id, label: n ?? t.id });\n  }\n  return r;\n}, xe = [\n  { id: \":\", labels: c({ \"en-gb\": \"Colon\" }) },\n  { id: \",\", labels: c({ \"en-gb\": \"Comma\" }) },\n  { id: \"!\", labels: c({ \"en-gb\": \"Exclamation Mark\" }) },\n  // { id: '', label: { 'en-gb': 'Other' } }, // TODO: Maybe set this to a 'not printing' or special ascii character when there is a user supplied delimited, rather than ''?\n  { id: \"0x1E\", labels: c({ \"en-gb\": \"Record Separator\" }) },\n  { id: \";\", labels: c({ \"en-gb\": \"Semicolon\" }) },\n  { id: \" \", labels: c({ \"en-gb\": \"Space\" }) },\n  { id: \"\t\", labels: c({ \"en-gb\": \"Tab\" }) },\n  { id: \"_\", labels: c({ \"en-gb\": \"Underscore\" }) },\n  { id: \"0x1F\", labels: c({ \"en-gb\": \"Unit Separator\" }) },\n  { id: \"|\", labels: c({ \"en-gb\": \"Vertical Bar\" }) }\n], Je = (e = I) => {\n  const r = [];\n  for (const t of xe) {\n    const n = L(t.labels, e);\n    r.push({ id: t.id, label: n ?? t.id });\n  }\n  return r;\n}, I = \"en-gb\";\nexport {\n  Ce as APIError,\n  w as ApplicationError,\n  we as CONNECTOR_DESTINATION_OPERATIONS,\n  Ie as CONNECTOR_SOURCE_OPERATIONS,\n  I as DEFAULT_LOCALE_CODE,\n  Me as EngineError,\n  z as FetchError,\n  Ae as OperationalError,\n  be as VueError,\n  je as WindowPromiseRejectionError,\n  Ne as WindowRuntimeError,\n  Re as buildFetchError,\n  Se as componentConfigSchema,\n  Te as concatenateSerialisedErrorMessages,\n  De as connectorConfigSchema,\n  Oe as contextConfigSchema,\n  Be as convertODataTypeIdToUsageTypeId,\n  Pe as extractExtensionFromPath,\n  Ge as extractNameFromPath,\n  m as formatNumberAsDecimalNumber,\n  He as formatNumberAsDuration,\n  ze as formatNumberAsSize,\n  Ve as formatNumberAsStorageSize,\n  N as formatNumberAsWholeNumber,\n  ke as getComponentStatus,\n  We as getDataFormats,\n  Xe as getRecordDelimiters,\n  Je as getValueDelimiters,\n  Ke as lookupMimeTypeForExtension,\n  $e as normalizeToError,\n  Le as presenterConfigSchema,\n  Fe as serialiseError,\n  _e as useCytoscapeJS,\n  Ue as useDataTable\n};\n","// Dependencies - Framework\nimport type * as RustModule from '../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js';\n\n// Interfaces/Types\ntype RustBindings = typeof RustModule;\n\n// Module Variables\nlet rustBindingsPromise: Promise<RustBindings> | undefined;\n\n// Utilities\nasync function addNumbersWithRust(left: number, right: number): Promise<number> {\n    const { add_my_numbers } = await loadRustBindings();\n    console.log(1111, left, right);\n    const yyyy = add_my_numbers(Math.trunc(left), Math.trunc(right));\n    console.log(2222, yyyy);\n    return yyyy;\n}\n\n// Utilities\nasync function checksumWithRust(input: string): Promise<number> {\n    const { checksum_from_rust } = await loadRustBindings();\n    return checksum_from_rust(input);\n}\n\n// Helpers\nasync function loadRustBindings(): Promise<RustBindings> {\n    rustBindingsPromise ??= import('../rust/datapos-connector-file-store-emulator-core/pkg/datapos_connector_file_store_emulator_core.js');\n    return rustBindingsPromise;\n}\n\n// Exposures\nexport { addNumbersWithRust, checksumWithRust };\n","/*\n * File store emulator connector class.\n */\n\n// NOTE: Consider Cloudflare R2 Download URL: https://plugins-eu.datapositioning.app/connectors/datapos-connector-file-store-emulator-es.js. This would allow us to secure the bucket?\n\n/** Dependencies - Vendor. */\nimport { nanoid } from 'nanoid';\n\n/** Dependencies - Framework. */\nimport { buildFetchError, extractExtensionFromPath, extractNameFromPath, lookupMimeTypeForExtension, normalizeToError, OperationalError } from '@datapos/datapos-shared';\nimport type {\n    ConnectionConfig,\n    ConnectionNodeConfig,\n    Connector,\n    ConnectorConfig,\n    ConnectorTools,\n    FindResult,\n    FindSettings,\n    GetReadableStreamResult,\n    GetReadableStreamSettings,\n    ListResult,\n    ListSettings,\n    PreviewResult,\n    PreviewSettings,\n    RetrieveRecordsSettings,\n    RetrieveRecordsSummary\n} from '@datapos/datapos-shared';\n\n/** Dependencies - Data. */\nimport config from '~/config.json';\nimport fileStoreIndex from '@/fileStoreIndex.json';\nimport { version } from '~/package.json';\nimport { addNumbersWithRust, checksumWithRust } from '@/rustBridge';\n\n/** Interfaces/Types - File store index. */\ntype FileStoreIndexItem =\n    | ({ typeId: 'folder'; childCount: number } & { name: string })\n    | ({ typeId: 'object'; id: string; lastModifiedAt: number; size: number } & { name: string });\ntype FileStoreIndex = Record<string, FileStoreIndexItem[]>;\n\n/** Constants */\nconst CALLBACK_PREVIEW_ABORTED = 'Connector failed to abort preview object operation.';\nconst CALLBACK_RETRIEVE_ABORTED = 'Connector failed to abort retrieve all records operation.';\nconst DEFAULT_PREVIEW_CHUNK_SIZE = 4096;\nconst DEFAULT_RETRIEVE_CHUNK_SIZE = 1000;\nconst URL_PREFIX = 'https://sample-data-eu.datapos.app';\n\n/** Classes - File store emulator connector. */\nexport default class FileStoreEmulatorConnector implements Connector {\n    abortController: AbortController | undefined;\n    readonly config: ConnectorConfig;\n    readonly connectionConfig: ConnectionConfig;\n    readonly tools: ConnectorTools;\n\n    constructor(connectionConfig: ConnectionConfig, tools: ConnectorTools) {\n        this.abortController = undefined;\n        this.config = config as ConnectorConfig;\n        this.config.version = version;\n        this.connectionConfig = connectionConfig;\n        this.tools = tools;\n    }\n\n    // Operations - Abort operation.\n    abortOperation(connector: FileStoreEmulatorConnector): void {\n        if (!connector.abortController) return;\n        connector.abortController.abort();\n        connector.abortController = undefined;\n    }\n\n    // Operations - Find object.\n    findObject(connector: FileStoreEmulatorConnector, settings: FindSettings): Promise<FindResult> {\n        // Loop through the file store index checking for an object entry with an identifier equal to the object name.\n        for (const folderPath in fileStoreIndex) {\n            if (Object.prototype.hasOwnProperty.call(fileStoreIndex, folderPath)) {\n                // eslint-disable-next-line security/detect-object-injection\n                const indexItems = (fileStoreIndex as FileStoreIndex)[folderPath];\n                const indexItem = indexItems?.find((indexItem) => indexItem.typeId === 'object' && indexItem.id === settings.objectName);\n                if (indexItem) return Promise.resolve({ folderPath }); // Found, return folder path.\n            }\n        }\n        return Promise.resolve({}); // Not found, return undefined folder path.\n    }\n\n    // Operations - Get readable stream.\n    async getReadableStream(connector: FileStoreEmulatorConnector, settings: GetReadableStreamSettings): Promise<GetReadableStreamResult> {\n        try {\n            console.log('getReader', 'connector', connector);\n            console.log('getReader', 'settings', settings);\n            const response = await fetch('https://sample-data-eu.datapos.app/fileStore/ENGAGEMENT_START_EVENTS_202405121858.csv');\n            // const response = await fetch('https://sample-data-eu.datapos.app/WDI_Data.csv');\n            console.log('getReader', 'response', response);\n            if (!response.body) throw new Error('ReadableStream not supported by this browser.');\n\n            const xxx = await addNumbersWithRust(12, 56);\n            const sum = await checksumWithRust(connector.config.version);\n            console.log('sum', sum, xxx);\n\n            return await Promise.resolve({ readable: response.body }); // Not found, return undefined folder path.\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - List nodes.\n    listNodes(connector: FileStoreEmulatorConnector, settings: ListSettings): Promise<ListResult> {\n        const indexItems = (fileStoreIndex as FileStoreIndex)[settings.folderPath] ?? [];\n        const connectionNodeConfigs: ConnectionNodeConfig[] = [];\n        for (const indexItem of indexItems) {\n            if (indexItem.typeId === 'folder') {\n                connectionNodeConfigs.push(this.constructFolderNodeConfig(settings.folderPath, indexItem.name, indexItem.childCount));\n            } else {\n                connectionNodeConfigs.push(this.constructObjectNodeConfig(settings.folderPath, indexItem.id, indexItem.name, indexItem.lastModifiedAt, indexItem.size));\n            }\n        }\n        return Promise.resolve({ cursor: undefined, isMore: false, connectionNodeConfigs, totalCount: connectionNodeConfigs.length });\n    }\n\n    // Operations - Preview object.\n    async previewObject(connector: FileStoreEmulatorConnector, settings: PreviewSettings): Promise<PreviewResult> {\n        try {\n            // Create an abort controller. Get the signal for the abort controller and add an abort listener.\n            connector.abortController = new AbortController();\n            const signal = connector.abortController.signal;\n            signal.addEventListener('abort', () => {\n                throw new OperationalError(CALLBACK_PREVIEW_ABORTED, 'datapos-connector-file-store-emulator|Connector|preview.abort');\n            });\n\n            // Fetch chunk from start of file.\n            const url = `${URL_PREFIX}/fileStore${settings.path}`;\n            const chunkSize = settings.chunkSize ?? DEFAULT_PREVIEW_CHUNK_SIZE;\n            const headers: HeadersInit = { Range: `bytes=0-${chunkSize}` };\n            const response = await fetch(encodeURI(url), { headers, signal });\n            if (response.ok) {\n                connector.abortController = undefined;\n                return { data: new Uint8Array(await response.arrayBuffer()), typeId: 'uint8Array' };\n            } else {\n                throw await buildFetchError(response, `Failed to fetch '${settings.path}' file.`, 'datapos-connector-file-store-emulator|Connector|preview');\n            }\n        } catch (error) {\n            connector.abortController = undefined;\n            throw error;\n        }\n    }\n\n    // Operations - Retrieve records.\n    async retrieveRecords(\n        connector: FileStoreEmulatorConnector,\n        settings: RetrieveRecordsSettings,\n        chunk: (records: string[][]) => void,\n        complete: (result: RetrieveRecordsSummary) => void\n    ): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                // Create an abort controller and get the signal. Add an abort listener to the signal.\n                connector.abortController = new AbortController();\n                const signal = connector.abortController.signal;\n                signal.addEventListener(\n                    'abort',\n                    () => {\n                        connector.abortController = undefined;\n                        reject(new OperationalError(CALLBACK_RETRIEVE_ABORTED, 'datapos-connector-file-store-emulator|Connector|retrieve.abort'));\n                    },\n                    { once: true }\n                );\n\n                // Parser - Declare variables.\n                let pendingRows: string[][] = []; // Array to store rows of parsed field values and associated information.\n\n                // Parser - Create a parser object for CSV parsing.\n                const parser = connector.tools.csvParse({\n                    delimiter: settings.valueDelimiterId,\n                    info: true,\n                    relax_column_count: true,\n                    relax_quotes: true\n                });\n\n                // Parser - Event listener for the 'readable' (data available) event.\n                parser.on('readable', () => {\n                    try {\n                        let data: string[] | null;\n                        while ((data = parser.read() as string[] | null) !== null) {\n                            signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                            pendingRows.push(data); // Append the row of parsed values and associated information to the pending rows array.\n                            if (pendingRows.length < DEFAULT_RETRIEVE_CHUNK_SIZE) continue; // Continue with next iteration if the pending rows array is not yet full.\n                            chunk([]); // Pass the pending rows to the engine using the 'chunk' callback.\n                            pendingRows = []; // Clear the pending rows array in preparation for the next batch of data.\n                        }\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Parser - Event listener for the 'error' event.\n                parser.on('error', (error) => {\n                    connector.abortController = undefined;\n                    reject(normalizeToError(error));\n                });\n\n                // Parser - Event listener for the 'end' (end of data) event.\n                parser.on('end', () => {\n                    try {\n                        signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                        connector.abortController = undefined; // Clear the abort controller.\n                        if (pendingRows.length > 0) {\n                            chunk([]);\n                            pendingRows = [];\n                        }\n                        complete({\n                            byteCount: parser.info.bytes,\n                            commentLineCount: parser.info.comment_lines,\n                            emptyLineCount: parser.info.empty_lines,\n                            invalidFieldLengthCount: parser.info.invalid_field_length,\n                            lineCount: parser.info.lines,\n                            recordCount: parser.info.records\n                        });\n                        resolve();\n                    } catch (error) {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    }\n                });\n\n                // Fetch, decode and forward the contents of the file to the parser.\n                const url = `${URL_PREFIX}/fileStore${settings.path}`;\n                fetch(encodeURI(url), { signal })\n                    .then(async (response) => {\n                        try {\n                            if (response.ok && response.body) {\n                                const stream = response.body.pipeThrough(new TextDecoderStream(settings.encodingId));\n                                const decodedStreamReader = stream.getReader();\n                                let result = await decodedStreamReader.read();\n                                while (!result.done) {\n                                    signal.throwIfAborted(); // Check if the abort signal has been triggered.\n                                    // Write the decoded data to the parser and terminate if there is an error.\n                                    parser.write(result.value, (error) => {\n                                        if (error) {\n                                            connector.abortController = undefined;\n                                            reject(normalizeToError(error));\n                                        }\n                                    });\n                                    result = await decodedStreamReader.read();\n                                }\n                                parser.end(); // Signal no more data will be written.\n                            } else {\n                                const error = await connector.tools.dataPos.buildFetchError(\n                                    response,\n                                    `Failed to fetch '${settings.path}' file.`,\n                                    'datapos-connector-file-store-emulator|Connector|retrieve'\n                                );\n                                connector.abortController = undefined;\n                                reject(error);\n                            }\n                        } catch (error) {\n                            connector.abortController = undefined;\n                            reject(normalizeToError(error));\n                        }\n                    })\n                    .catch((error: unknown) => {\n                        connector.abortController = undefined;\n                        reject(normalizeToError(error));\n                    });\n            } catch (error) {\n                connector.abortController = undefined;\n                reject(normalizeToError(error));\n            }\n        });\n    }\n\n    /** Utilities - Construct folder node configuration. */\n    private constructFolderNodeConfig(folderPath: string, name: string, childCount: number): ConnectionNodeConfig {\n        return { id: nanoid(), childCount, folderPath, label: name, name, typeId: 'folder' };\n    }\n\n    /** Utilities - Construct object (file) node configuration. */\n    private constructObjectNodeConfig(folderPath: string, id: string, fullName: string, lastModifiedAt: number, size: number): ConnectionNodeConfig {\n        const name = extractNameFromPath(fullName) ?? '';\n        const extension = extractExtensionFromPath(fullName);\n        const lastModifiedAtTimestamp = lastModifiedAt;\n        const mimeType = lookupMimeTypeForExtension(extension);\n        return { id, extension, folderPath, label: fullName, lastModifiedAt: lastModifiedAtTimestamp, mimeType, name, size, typeId: 'object' };\n    }\n}\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","j","H","K","W","X","J","q","Q","r","U","g","t","n","s","o","i","u","a","p","d","h","Z","D","_","G","v","E","O","F","w","z","Ae","Re","$e","Ge","Pe","Ke","rustBindingsPromise","addNumbersWithRust","left","right","add_my_numbers","loadRustBindings","yyyy","checksumWithRust","input","checksum_from_rust","CALLBACK_PREVIEW_ABORTED","CALLBACK_RETRIEVE_ABORTED","DEFAULT_PREVIEW_CHUNK_SIZE","DEFAULT_RETRIEVE_CHUNK_SIZE","URL_PREFIX","FileStoreEmulatorConnector","connectionConfig","tools","config","version","connector","settings","folderPath","fileStoreIndex","indexItem","response","xxx","sum","error","indexItems","connectionNodeConfigs","signal","OperationalError","url","headers","buildFetchError","chunk","complete","resolve","reject","pendingRows","parser","data","normalizeToError","decodedStreamReader","result","name","childCount","fullName","lastModifiedAt","extractNameFromPath","extension","extractExtensionFromPath","lastModifiedAtTimestamp","mimeType","lookupMimeTypeForExtension"],"mappings":"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","x_google_ignoreList":[0,1,2]}